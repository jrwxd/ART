<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Tarot Slots - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel+Decorative:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'MedievalSharp', cursive;
            color: #e2d8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            overflow-x: hidden;
            /* Animated gradient background */
            background: linear-gradient(45deg, #0f0b1a, #1a1025, #2d1a3b, #3b1f4a, #2d1a3b, #1a1025);
            background-size: 600% 600%; /* Increased size for slower, smoother animation */
            animation: gradientBG 35s ease infinite;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .slot-machine-container {
            background: linear-gradient(145deg, #2d243b, #1a1025);
            border: 10px solid #4a3968;
            border-image: linear-gradient(to bottom right, #b68fd8, #8a4bdb, #6a0dad) 1;
            border-radius: 25px;
            padding: 1.5rem 2rem;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4), 0 0 40px rgba(106,13,173,0.2) inset, 0 0 15px rgba(142, 68, 173, 0.3);
            text-align: center;
            width: 100%;
            max-width: 700px;
            transition: box-shadow 0.3s ease-in-out, border-image 0.3s ease-in-out;
            position: relative; /* For particle positioning */
        }

        @keyframes arcaneGlow {
            0%, 100% {
                border-image: linear-gradient(45deg, #e7c6ff, #ad70f0, #8a2be2, #c06eff) 1;
                box-shadow: 0 15px 35px rgba(0,0,0,0.6),
                            0 0 80px rgba(148,0,211,0.9) inset, /* Deeper purple glow */
                            0 0 50px rgba(186,85,211,0.8), /* Orchid */
                            0 0 10px rgba(255,255,255,0.5); /* Softer white hot center */
                transform: scale(1.005);
            }
            50% {
                border-image: linear-gradient(45deg, #c06eff, #8a2be2, #ad70f0, #e7c6ff) 1;
                box-shadow: 0 20px 45px rgba(0,0,0,0.8),
                            0 0 120px rgba(148,0,211,1) inset, /* More intense */
                            0 0 70px rgba(186,85,211,1),
                            0 0 15px rgba(255,255,255,0.7);
                transform: scale(1.015); /* Slightly more pronounced pulse */
            }
        }

        .slot-machine-container.big-win-celebration {
            animation: arcaneGlow 0.7s ease-in-out infinite alternate;
        }

        .reels-area {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            background-color: #0a0612;
            padding: 1.5rem;
            border-radius: 15px;
            border: 6px solid #614785;
            box-shadow: 0 8px 15px rgba(0,0,0,0.3) inset;
        }

        .reel-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }

        .reel-cell {
            width: 70px;
            height: 95px;
            background-color: #1e102d;
            border: 4px solid #7850a9;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            line-height: 1;
            color: #d5c5f0;
            overflow: hidden;
            margin-bottom: 5px;
            transition: transform 0.15s ease-out, background-color 0.2s, box-shadow 0.2s, filter 0.2s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            position: relative;
        }

        .reel-cell-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .tarot-icon {
            font-size: 2rem; /* Slightly larger for better visibility */
            margin-bottom: 3px;
        }

        .tarot-name {
            font-size: 0.55rem; /* Slightly larger */
            font-family: 'Cinzel Decorative', cursive;
            white-space: nowrap;
            font-weight: bold;
        }

        .reel-cell:last-child {
            margin-bottom: 0;
        }

        .reel-cell.spinning-effect {
            animation: spinAnimation 0.04s linear infinite; /* Slightly faster visual tumble */
        }

        @keyframes spinAnimation { /* More dynamic tumble */
            0% { transform: translateY(-10px) rotateX(15deg) scaleY(0.95); opacity: 0.6; }
            25% { transform: translateY(5px) rotateX(-7deg); opacity: 0.8; }
            50% { transform: translateY(10px) rotateX(-15deg) scaleY(0.95); opacity: 1; }
            75% { transform: translateY(-5px) rotateX(7deg); opacity: 0.8; }
            100% { transform: translateY(-10px) rotateX(15deg) scaleY(0.95); opacity: 0.6; }
        }

        .reel-cell.winning {
            background-color: #5a009d; /* Brighter purple */
            color: #fff;
            border-color: #c585ff; /* Lighter, glowing border */
            transform: scale(1.15); /* Keep existing scale */
            animation: winningCellPulse 0.5s infinite alternate;
        }

        @keyframes winningCellPulse { /* More glitter */
            from {
                transform: scale(1.12);
                box-shadow: 0 0 20px #b68fd8, 0 0 35px #d09fff inset, 0 0 8px #ffffff;
                filter: brightness(1.3);
            }
            to {
                transform: scale(1.22);
                box-shadow: 0 0 30px #d09fff, 0 0 45px #e7c6ff inset, 0 0 12px #ffffff;
                filter: brightness(1.6);
            }
        }

        .bet-selection-area {
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
        }

        .bet-button {
            background: linear-gradient(145deg, #673ab7, #512da8);
            color: #e6d8fc;
            font-family: 'Cinzel Decorative', cursive;
            font-size: 0.8rem;
            padding: 0.5rem 0.75rem;
            border: 2px solid #9575cd;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 3px #4527a0, 0 0 5px rgba(182, 143, 216, 0); /* Initial transparent glow */
            transition: all 0.1s ease-in-out, box-shadow 0.2s ease;
        }

        .bet-button:hover {
            background: linear-gradient(145deg, #7e57c2, #673ab7);
            box-shadow: 0 2px #4527a0, 0 0 10px rgba(200, 160, 230, 0.7); /* Glow on hover */
            transform: translateY(-1px) scale(1.03);
        }

        .bet-button.active {
            background: linear-gradient(145deg, #5e35b1, #4527a0);
            color: #fff;
            box-shadow: 0 1px #311b92 inset, 0 0 12px rgba(220, 190, 255, 0.8); /* Inner shadow and stronger glow */
            transform: translateY(1px) scale(1.02);
            border-color: #bca0e0;
        }

        .controls-container {
            margin-top: 1rem;
        }

        .spin-button {
            background: linear-gradient(145deg, #9c27b0, #7b1fa2);
            color: #f3e5f5;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: bold;
            font-size: 1.4rem;
            padding: 1rem 2rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s ease-in-out, box-shadow 0.1s ease-in-out, transform 0.1s ease-in-out;
            animation: subtlePulse 2.5s infinite ease-in-out;
        }
        @keyframes subtlePulse { /* For spin button */
            0%, 100% {
                box-shadow: 0 6px #6a1b9a, 0 10px 20px rgba(0,0,0,0.3), 0 0 12px rgba(220, 180, 255, 0.2);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 6px #6a1b9a, 0 10px 25px rgba(0,0,0,0.4), 0 0 22px rgba(220, 180, 255, 0.45);
                transform: scale(1.02);
            }
        }

        .spin-button:hover {
            background: linear-gradient(145deg, #ab47bc, #8e24aa);
            box-shadow: 0 4px #6a1b9a, 0 8px 16px rgba(0,0,0,0.25), 0 0 25px rgba(230, 190, 255, 0.6);
            transform: translateY(-2px) scale(1.05); /* More lift and scale */
            animation-play-state: paused; /* Pause pulse on hover */
        }

        .spin-button:active {
            background: linear-gradient(145deg, #8e24aa, #6a1b9a);
            box-shadow: 0 2px #4a148c inset, 0 5px 10px rgba(0,0,0,0.2); /* Inner shadow */
            transform: translateY(1px) scale(1.02);
        }

        .spin-button:disabled {
            background: #5b6270; /* Darker disabled */
            color: #909ab0;
            box-shadow: 0 6px #404853 inset;
            cursor: not-allowed;
            transform: translateY(0) scale(1);
            animation: none;
        }

        .info-display {
            margin-top: 2rem;
            font-size: 1.1rem;
            background-color: rgba(38, 23, 51, 0.8); /* Slightly more transparent */
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.25) inset, 0 0 10px rgba(74, 57, 104, 0.3);
        }

        .balance-display, .message-display {
            margin-bottom: 0.75rem;
        }

        .balance-amount {
            color: #dda0dd; /* Plum, slightly softer */
            font-weight: bold;
            text-shadow: 1px 1px 3px #5d337a;
        }

        .message-text {
            color: #40e0d0; /* Turquoise */
            min-height: 28px;
            font-size: 0.9rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px #018786;
            transition: color 0.3s ease, text-shadow 0.3s ease, opacity 0.4s ease-out;
            opacity: 1;
        }
        .message-text.fade-out {
            opacity: 0;
        }

        .message-text.error {
            color: #ff69b4; /* Hot Pink for error */
            text-shadow: 1px 1px 2px #b00020;
        }

        .title {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 2.3rem; /* Slightly larger */
            margin-bottom: 1.5rem;
            color: #e7c6ff; /* Lighter purple for title */
            text-shadow: 3px 3px #5a106d, 6px 6px #2a004f, 0 0 15px rgba(231, 198, 255, 0.5); /* Enhanced shadow */
            font-weight: 900;
        }

        .tarot-legends {
            margin-top: 1.5rem;
            background-color: rgba(38, 23, 51, 0.8);
            padding: 1rem;
            border-radius: 10px;
            font-size: 0.8rem;
        }

        .legend-title {
            font-family: 'Cinzel Decorative', cursive;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #dda0dd;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-icon {
            font-size: 1.2rem;
        }

        /* Particle Styles */
        .sparkle-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            opacity: 1;
            transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.6s ease-out; /* Added cubic-bezier for bouncier feel */
        }
        .coin-particle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: gold;
            border: 1px solid #b8860b; /* DarkGoldenRod */
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            opacity: 0.95;
            transition: transform 1.2s cubic-bezier(0.39, 0.575, 0.565, 1), opacity 1s ease-in; /* Gravity feel */
            box-shadow: 0 0 5px yellow;
        }


        @media (max-width: 640px) {
            .slot-machine-container { padding: 1rem; max-width: 100%; }
            .reels-area { padding: 0.75rem; }
            .reel-column { margin: 0 2px; }
            .reel-cell {
                width: calc((100vw - 60px) / 5); /* Adjusted for slightly smaller margins */
                height: calc((100vw - 60px) / 3.8); /* Adjusted height ratio */
                font-size: 1.5rem;
            }
            .tarot-icon { font-size: 1.3rem; }
            .tarot-name { font-size: 0.45rem; }
            .title { font-size: 1.6rem; margin-bottom: 1.2rem;}
            .spin-button { font-size: 1.2rem; padding: 0.75rem 1.5rem; }
            .bet-button { font-size: 0.7rem; padding: 0.4rem 0.6rem; }
            .info-display { font-size: 0.9rem; }
            .message-text { font-size: 0.8rem; min-height: 24px; }
        }
        @media (max-width: 400px) {
            .tarot-icon { font-size: 1.1rem; }
            .tarot-name { font-size: 0.38rem; } /* Ensure readability */
            .title { font-size: 1.4rem; }
            .reel-cell {
                 width: calc((100vw - 50px) / 5);
                 height: calc((100vw - 50px) / 3.5);
            }
        }
    </style>
</head>
<body>
    <div class="slot-machine-container" id="slotMachineContainer">
        <h1 class="title">Mystic Tarot Slots</h1>
        <div class="bet-selection-area" id="betSelectionArea">
            </div>
        <div class="reels-area" id="reelsArea">
            </div>
        <div class="controls-container">
            <button id="spinButton" class="spin-button">Divine Fate</button>
        </div>
        <div class="info-display">
            <div class="balance-display">Arcane Power: <span id="balanceAmount" class="balance-amount">1000.00</span></div>
            <div class="message-display">Mystical Guidance: <span id="messageText" class="message-text">The cards await your destiny...</span></div>
        </div>
        <div class="tarot-legends">
            <div class="legend-title">Mystical Cards Guide</div>
            <div class="legend-grid" id="legendGrid">
                </div>
        </div>
    </div>

    <script>
        // --- Game Configuration ---
        const tarotCards = [
            { symbol: 'â­', name: 'Star', payouts: { 5: 300, 4: 100, 3: 2.5 } },
            { symbol: 'ï¿½', name: 'Moon', payouts: { 5: 250, 4: 80, 3: 2 } },
            { symbol: 'â˜€ï¸', name: 'Sun', payouts: { 5: 1000, 4: 300, 3: 8 } }, // High value
            { symbol: 'âš¡', name: 'Tower', payouts: { 5: 500, 4: 150, 3: 4 } },
            { symbol: 'ðŸ”®', name: 'Crystal', payouts: { 5: 200, 4: 70, 3: 1.5 } },
            { symbol: 'ðŸ—¡ï¸', name: 'Sword', payouts: { 5: 600, 4: 200, 3: 5 } },
            { symbol: 'ðŸ†', name: 'Chalice', payouts: { 5: 150, 4: 50, 3: 1.2 } }, // Common
            { symbol: 'ðŸ‘‘', name: 'Emperor', payouts: { 5: 800, 4: 250, 3: 6 } },
            { symbol: 'ðŸ‘¸', name: 'Empress', payouts: { 5: 800, 4: 250, 3: 6 } },
            { symbol: 'ðŸ§™', name: 'Magician', payouts: { 5: 1500, 4: 400, 3: 10 } }, // Rare
            { symbol: 'ðŸ¦‰', name: 'Priestess', payouts: { 5: 1500, 4: 400, 3: 10 } }, // Renamed for brevity
            { symbol: 'ðŸ’€', name: 'Death', payouts: { 5: 2000, 4: 500, 3: 15 } }, // Very Rare
            { symbol: 'ðŸƒ', name: 'Fool', payouts: { 5: 2500, 4: 600, 3: 20 } }  // Top Rare
        ];

        const baseSpinCost = 10;
        const initialBalance = 1000;
        const NUM_REELS = 5;
        const NUM_ROWS = 3;
        const betMultiplierOptions = [
            { label: '0.25x', value: 0.25 },
            { label: '0.5x', value: 0.5 },
            { label: '1x', value: 1.0 },
            { label: '2x', value: 2.0 },
            { label: '5x', value: 5.0 } // Added higher bet
        ];
        const payouts = {};
        tarotCards.forEach(card => { payouts[card.symbol] = card.payouts; });

        const createVirtualReelStrip = (reelNumber) => {
            const strip = [];
            tarotCards.forEach(card => {
                let frequency;
                const symbolValue = Math.max(...Object.values(card.payouts));
                if (symbolValue >= 2000) { // Fool, Death
                    frequency = Math.max(1, 3 - reelNumber * 0.5);
                } else if (symbolValue >= 1000) { // Magician, Priestess, Sun
                    frequency = Math.max(1, 5 - reelNumber * 0.8);
                } else if (symbolValue >= 500) { // Emperor, Empress, Sword, Tower
                    frequency = Math.max(2, 8 - reelNumber * 1);
                } else { // Common: Star, Moon, Crystal, Chalice
                    frequency = Math.max(4, 12 - reelNumber * 0.5);
                }
                for (let i = 0; i < Math.floor(frequency); i++) { strip.push(card.symbol); }
            });
            return strip.sort(() => Math.random() - 0.5);
        };

        const virtualReelStrips = Array.from({ length: NUM_REELS }, (_, i) => createVirtualReelStrip(i));

        const paylines = [
            Array.from({ length: NUM_REELS }, (_, col) => ({ col, row: 0 })), // Top row
            Array.from({ length: NUM_REELS }, (_, col) => ({ col, row: 1 })), // Middle row
            Array.from({ length: NUM_REELS }, (_, col) => ({ col, row: 2 })), // Bottom row
            [{col:0,row:0}, {col:1,row:1}, {col:2,row:2}, {col:3,row:1}, {col:4,row:0}], // V shape
            [{col:0,row:2}, {col:1,row:1}, {col:2,row:0}, {col:3,row:1}, {col:4,row:2}], // Inverse V
            [{col:0,row:0}, {col:1,row:0}, {col:2,row:1}, {col:3,row:2}, {col:4,row:2}],
            [{col:0,row:2}, {col:1,row:2}, {col:2,row:1}, {col:3,row:0}, {col:4,row:0}],
            [{col:0,row:1}, {col:1,row:0}, {col:2,row:0}, {col:3,row:0}, {col:4,row:1}], // U
            [{col:0,row:1}, {col:1,row:2}, {col:2,row:2}, {col:3,row:2}, {col:4,row:1}], // Inverse U
            [{col:0,row:0}, {col:1,row:1}, {col:2,row:1}, {col:3,row:1}, {col:4,row:0}], // W-ish
            [{col:0,row:2}, {col:1,row:1}, {col:2,row:1}, {col:3,row:1}, {col:4,row:2}]  // M-ish
        ];

        // --- DOM Elements ---
        const slotMachineContainer = document.getElementById('slotMachineContainer');
        const reelsArea = document.getElementById('reelsArea');
        const spinButton = document.getElementById('spinButton');
        const balanceAmountDisplay = document.getElementById('balanceAmount');
        const messageTextDisplay = document.getElementById('messageText');
        const betSelectionArea = document.getElementById('betSelectionArea');
        const legendGrid = document.getElementById('legendGrid');
        const reelCells = [];

        // --- Game State ---
        let currentBalance = initialBalance;
        let isSpinning = false;
        let predeterminedOutcome = [];
        let currentBetMultiplier = 1.0;
        let reelVisualSpinIndices = Array(NUM_REELS).fill(0);
        let messageTimeout;

        // --- Tone.js Sound Synthesizers ---
        let spinSound, reelStopSound, smallWinSound, mediumWinSound, bigWinSound, jackpotSound, noBalanceSound, clickSound;
        let soundsInitialized = false;

        function initializeSounds() {
            if (typeof Tone === 'undefined' || soundsInitialized || (Tone.context && Tone.context.state === 'running')) {
                soundsInitialized = true; return;
            }
            Tone.start().then(() => {
                console.log("Audio context started.");
                spinSound = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.05, release: 0.2 } }).toDestination();
                spinSound.volume.value = -20;

                reelStopSound = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 3, oscillator: {type: "sine"}, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2} }).toDestination();
                reelStopSound.volume.value = -15;

                smallWinSound = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination();
                smallWinSound.volume.value = -14;

                mediumWinSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fmtriangle', modulationType: 'square', harmonicity: 0.5 }, envelope: { attack: 0.02, decay: 0.4, sustain: 0.2, release: 0.5 } }).toDestination();
                mediumWinSound.volume.value = -10;

                bigWinSound = new Tone.PolySynth(Tone.FMSynth, { harmonicity: 1.5, modulationIndex: 12, detune: -5, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.3, release: 0.8 }, modulation: { type: 'triangle' }, modulationEnvelope: { attack: 0.05, decay: 0.3, sustain: 0.5, release: 0.8 } }).toDestination();
                bigWinSound.volume.value = -8;

                jackpotSound = new Tone.PolySynth(Tone.Synth, { oscillator: {type: "pulse", width: 0.2}, envelope: { attack: 0.01, decay: 1.5, sustain: 0.5, release: 2.0 } }).toDestination();
                const jackpotReverb = new Tone.Reverb(1.5).toDestination();
                jackpotSound.connect(jackpotReverb);
                jackpotSound.volume.value = -6;


                noBalanceSound = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
                noBalanceSound.volume.value = -12;

                clickSound = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                clickSound.volume.value = -18;

                soundsInitialized = true;
            }).catch(e => console.error("Error starting Tone.js audio context:", e));
        }

        // --- Particle Effects ---
        function createParticle(options) {
            const particle = document.createElement('div');
            particle.classList.add(options.type === 'coin' ? 'coin-particle' : 'sparkle-particle');
            particle.style.left = `${options.x}px`;
            particle.style.top = `${options.y}px`;
            if (options.type !== 'coin') { // Sparkles get random colors
                 particle.style.backgroundColor = `hsl(${Math.random() * 60 + 240 + (options.colorHueShift || 0)}, 100%, ${70 + Math.random()*15}%)`; // Purples, Pinks, with some variation
            }

            options.container.appendChild(particle);

            // Initial state for animation (e.g., small and centered)
            particle.style.transform = `translate(-50%, -50%) scale(0.1) rotate(0deg)`;

            setTimeout(() => { // Animate out
                const angle = options.angle || (Math.random() * Math.PI * 2);
                const distance = options.distance || (Math.random() * 60 + 30); // 30 to 90px
                const rotation = options.rotation || (Math.random() * 720 - 360); // Random rotation

                if (options.type === 'coin') {
                    particle.style.transform = `translate(${Math.cos(angle) * distance * 0.5}px, ${distance * 1.5 + Math.random()*20}px) scale(1) rotate(${rotation}deg)`; // Fall down
                } else {
                     particle.style.transform = `translate(${Math.cos(angle) * distance - particle.offsetWidth/2}px, ${Math.sin(angle) * distance - particle.offsetHeight/2}px) scale(${Math.random() * 0.5 + 0.8}) rotate(${rotation}deg)`;
                }
                particle.style.opacity = '0';
            }, 10);

            setTimeout(() => {
                particle.remove();
            }, options.duration || 700); // Default duration 700ms
        }

        function triggerSparkleExplosion(x, y, count = 10, container = slotMachineContainer, colorHueShift = 0) {
            for (let i = 0; i < count; i++) {
                createParticle({ x, y, container, type: 'sparkle', colorHueShift });
            }
        }
        function triggerCoinShower(count = 30, container = slotMachineContainer) {
            let releasedCoins = 0;
            const interval = setInterval(() => {
                if (releasedCoins >= count) {
                    clearInterval(interval);
                    return;
                }
                createParticle({
                    x: Math.random() * container.offsetWidth,
                    y: -10, // Start above
                    container,
                    type: 'coin',
                    angle: Math.PI / 2, // Mostly downwards
                    distance: container.offsetHeight + 20,
                    duration: 1200 + Math.random() * 500
                });
                releasedCoins++;
            }, 60); // Release a coin every 60ms
        }


        // --- UI & Game Logic ---
        function createBetButtons() {
            betSelectionArea.innerHTML = '';
            betMultiplierOptions.forEach(option => {
                const button = document.createElement('button');
                button.classList.add('bet-button');
                button.textContent = option.label;
                button.dataset.multiplier = option.value;
                if (option.value === currentBetMultiplier) button.classList.add('active');
                button.addEventListener('click', () => {
                    if (!soundsInitialized) initializeSounds();
                    if (soundsInitialized && clickSound) clickSound.triggerAttackRelease('G5', '32n', Tone.now());
                    currentBetMultiplier = parseFloat(option.value);
                    updateSpinButtonText();
                    document.querySelectorAll('.bet-button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
                betSelectionArea.appendChild(button);
            });
        }

        function updateSpinButtonText() {
            const cost = baseSpinCost * currentBetMultiplier;
            spinButton.textContent = `Divine Fate (${cost.toFixed(2)})`;
        }

        function createLegend() {
            legendGrid.innerHTML = '';
            tarotCards.forEach(card => {
                const item = document.createElement('div');
                item.classList.add('legend-item');
                const icon = document.createElement('span');
                icon.classList.add('legend-icon');
                icon.textContent = card.symbol;
                const name = document.createElement('span');
                name.textContent = `${card.name} (3x: ${card.payouts[3]}, 4x: ${card.payouts[4]}, 5x: ${card.payouts[5]})`; // Show payouts
                item.appendChild(icon);
                item.appendChild(name);
                legendGrid.appendChild(item);
            });
        }

        function createReelGrid() {
            reelsArea.innerHTML = '';
            for (let col = 0; col < NUM_REELS; col++) {
                const columnDiv = document.createElement('div');
                columnDiv.classList.add('reel-column');
                reelCells[col] = [];
                for (let row = 0; row < NUM_ROWS; row++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('reel-cell');
                    cellDiv.id = `cell-${col}-${row}`;
                    const cellContent = document.createElement('div');
                    cellContent.classList.add('reel-cell-content');
                    const iconElement = document.createElement('div');
                    iconElement.classList.add('tarot-icon');
                    const nameElement = document.createElement('div');
                    nameElement.classList.add('tarot-name');
                    cellContent.appendChild(iconElement);
                    cellContent.appendChild(nameElement);
                    cellDiv.appendChild(cellContent);
                    columnDiv.appendChild(cellDiv);
                    reelCells[col][row] = cellDiv;
                }
                reelsArea.appendChild(columnDiv);
            }
        }

        function setReelDisplay(symbolGrid) {
            for (let col = 0; col < NUM_REELS; col++) {
                for (let row = 0; row < NUM_ROWS; row++) {
                    if (reelCells[col] && reelCells[col][row] && symbolGrid[col] && symbolGrid[col][row]) {
                        const cell = reelCells[col][row];
                        const symbol = symbolGrid[col][row];
                        const card = tarotCards.find(c => c.symbol === symbol);
                        const iconElement = cell.querySelector('.tarot-icon');
                        const nameElement = cell.querySelector('.tarot-name');
                        if (iconElement && nameElement && card) {
                            iconElement.textContent = card.symbol;
                            nameElement.textContent = card.name;
                        }
                    }
                }
            }
        }
        function initializeGame() {
            createReelGrid();
            createLegend();
            predeterminedOutcome = generateOutcomeFromVirtualReels();
            setReelDisplay(predeterminedOutcome);
            createBetButtons();
            updateBalanceDisplay();
            updateSpinButtonText();

            const spinHandler = () => {
                if (!soundsInitialized && !(typeof Tone !== 'undefined' && Tone.context && Tone.context.state === 'running')) {
                    initializeSounds();
                    setTimeout(() => {
                        if (soundsInitialized || (typeof Tone !== 'undefined' && Tone.context && Tone.context.state === 'running')) {
                            handleSpin();
                        } else {
                            showMessage("Click 'Divine Fate' again to enable sound & spin.", true, 3000);
                        }
                    }, 250);
                } else {
                    handleSpin();
                }
            };
            if (spinButton._clickHandler) { spinButton.removeEventListener('click', spinButton._clickHandler); }
            spinButton.addEventListener('click', spinHandler);
            spinButton._clickHandler = spinHandler;
        }

        function generateOutcomeFromVirtualReels() {
            const newGrid = [];
            for (let col = 0; col < NUM_REELS; col++) {
                newGrid[col] = [];
                const currentReelStrip = virtualReelStrips[col];
                const stripLength = currentReelStrip.length;
                const startIndex = Math.floor(Math.random() * stripLength);
                for (let row = 0; row < NUM_ROWS; row++) {
                    const offset = row - Math.floor(NUM_ROWS / 2);
                    const stripIndex = (startIndex + offset + stripLength) % stripLength;
                    newGrid[col][row] = currentReelStrip[stripIndex];
                }
            }
            return newGrid;
        }

        function updateBalanceDisplay() {
            balanceAmountDisplay.textContent = currentBalance.toFixed(2);
        }

        function showMessage(text, isError = false, duration = 4000) {
            clearTimeout(messageTimeout);
            messageTextDisplay.classList.remove('fade-out');
            messageTextDisplay.textContent = text;
            messageTextDisplay.classList.toggle('error', isError);
            messageTextDisplay.style.opacity = '1'; // Ensure visible before fade

            if (duration > 0) {
                messageTimeout = setTimeout(() => {
                    messageTextDisplay.classList.add('fade-out');
                }, duration);
            }
        }

        function clearWinningHighlights() {
            slotMachineContainer.classList.remove('big-win-celebration');
            reelCells.forEach(columnOfCells => columnOfCells.forEach(cell => cell.classList.remove('winning')));
        }

        const REEL_SPIN_DURATION_BASE = 700; // ms
        const REEL_SPIN_STAGGER = 200;    // ms

        async function handleSpin() {
            if (isSpinning) return;
            const currentSpinCost = parseFloat((baseSpinCost * currentBetMultiplier).toFixed(2));
            if (currentBalance < currentSpinCost) {
                showMessage('Not enough Arcane Power!', true, 3000);
                if (soundsInitialized && noBalanceSound) noBalanceSound.triggerAttackRelease('A2', '8n', Tone.now());
                return;
            }
            isSpinning = true;
            spinButton.disabled = true;
            slotMachineContainer.classList.remove('big-win-celebration');
            currentBalance -= currentSpinCost;
            updateBalanceDisplay();
            showMessage('The ether shifts...', false, 0); // Persistent until win/loss message
            clearWinningHighlights();
            if (soundsInitialized && spinSound) spinSound.triggerAttackRelease("2n", Tone.now()); // Longer spin sound

            predeterminedOutcome = generateOutcomeFromVirtualReels();
            const reelAnimationPromises = [];
            for (let col = 0; col < NUM_REELS; col++) {
                reelVisualSpinIndices[col] = Math.floor(Math.random() * (virtualReelStrips[col] ? virtualReelStrips[col].length : 10));
                reelAnimationPromises.push(animateSingleReel(col, REEL_SPIN_DURATION_BASE + col * REEL_SPIN_STAGGER));
            }
            await Promise.all(reelAnimationPromises);
            setReelDisplay(predeterminedOutcome);

            const { totalWinnings, winningPaylines } = calculateWinnings(predeterminedOutcome, currentBetMultiplier);
            if (totalWinnings > 0) {
                currentBalance += totalWinnings;
                currentBalance = parseFloat(currentBalance.toFixed(2));
                updateBalanceDisplay();
                highlightWinningCells(winningPaylines); // This will also trigger sparkles per cell
                showMessage(`Mystic Win! +${totalWinnings.toFixed(2)}!`, false, 5000);

                const effectiveSpinCost = baseSpinCost * currentBetMultiplier;
                if (totalWinnings >= effectiveSpinCost * 50) { // Jackpot win
                    if (soundsInitialized && jackpotSound) jackpotSound.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5", "G5"], "1.5n", Tone.now());
                    slotMachineContainer.classList.add('big-win-celebration');
                    triggerCoinShower(50); // More coins for jackpot
                    // Global sparkles for jackpot
                    const machineRect = slotMachineContainer.getBoundingClientRect();
                    const centerX = machineRect.left + window.scrollX + machineRect.width / 2;
                    const centerY = machineRect.top + window.scrollY + machineRect.height / 2;
                    triggerSparkleExplosion(centerX, centerY, 30, document.body, 30); // Gold-ish sparkles from center
                } else if (totalWinnings >= effectiveSpinCost * 10) { // Big win
                    if (soundsInitialized && bigWinSound) bigWinSound.triggerAttackRelease(["C4", "G4", "C5", "E5"], "0.8n", Tone.now());
                    slotMachineContainer.classList.add('big-win-celebration');
                    triggerCoinShower(25);
                } else if (totalWinnings >= effectiveSpinCost * 3) { // Medium win
                    if (soundsInitialized && mediumWinSound) mediumWinSound.triggerAttackRelease(["E4", "A4", "C#5"], "0.5n", Tone.now());
                } else { // Small win
                    if (soundsInitialized && smallWinSound) smallWinSound.triggerAttackRelease('A4', '0.2n', Tone.now() + 0.05);
                }
            } else {
                showMessage('The spirits are silent this time.', false, 3000);
            }
            isSpinning = false;
            spinButton.disabled = false;
        }

        const VISUAL_UPDATE_INTERVAL = 50; // ms, affects visual speed of spinning symbols

        function animateSingleReel(col, duration) {
            return new Promise(resolve => {
                const reelColumnCells = reelCells[col];
                const strip = virtualReelStrips[col];
                if (!strip || strip.length === 0) {
                    reelColumnCells.forEach(cell => cell.classList.remove('spinning-effect'));
                    resolve(); return;
                }
                const stripLength = strip.length;
                let startTime = null;
                let lastUpdateTime = 0;
                reelColumnCells.forEach(cell => cell.classList.add('spinning-effect'));

                function animationStep(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = timestamp - startTime;

                    if (timestamp - lastUpdateTime > VISUAL_UPDATE_INTERVAL) {
                        lastUpdateTime = timestamp;
                        reelVisualSpinIndices[col] = (reelVisualSpinIndices[col] + 1) % stripLength;
                        for (let row = 0; row < NUM_ROWS; row++) {
                            const currentSymbolIndexOnStrip = (reelVisualSpinIndices[col] + row - Math.floor(NUM_ROWS / 2) + stripLength) % stripLength;
                            const symbolForCell = strip[currentSymbolIndexOnStrip];
                            const card = tarotCards.find(c => c.symbol === symbolForCell);
                            const cell = reelColumnCells[row];
                            const iconElement = cell.querySelector('.tarot-icon');
                            const nameElement = cell.querySelector('.tarot-name');
                            if (iconElement && card) {
                                iconElement.textContent = card.symbol;
                                if (nameElement) nameElement.textContent = card.name.substring(0, Math.min(card.name.length, 5)) + (card.name.length > 5 ? '.' : ''); // Shortened name
                            } else if (iconElement && symbolForCell) {
                                iconElement.textContent = symbolForCell;
                                if (nameElement) nameElement.textContent = '';
                            }
                        }
                    }

                    if (progress < duration) {
                        requestAnimationFrame(animationStep);
                    } else {
                        reelColumnCells.forEach(cell => cell.classList.remove('spinning-effect'));
                        // Final outcome is set globally after all animations
                        if (soundsInitialized && reelStopSound) reelStopSound.triggerAttackRelease(`G${2 + col % 2}`, '8n', Tone.now() + Math.random() * 0.03); // Staggered pitch
                        resolve();
                    }
                }
                requestAnimationFrame(animationStep);
            });
        }

        function calculateWinnings(grid, betMultiplier) {
            let totalWinnings = 0;
            const winningPaylinesDetails = [];
            paylines.forEach((paylineCoords, paylineIndex) => {
                const symbolsOnPayline = paylineCoords.map(coord => grid[coord.col][coord.row]);
                const firstSymbol = symbolsOnPayline[0];
                if (!firstSymbol) return;
                let consecutiveCount = 0;
                for (const symbol of symbolsOnPayline) {
                    if (symbol === firstSymbol) { consecutiveCount++; }
                    else { break; }
                }
                const cardPayoutData = payouts[firstSymbol];
                if (cardPayoutData && cardPayoutData[consecutiveCount]) {
                    const payoutMultiplierValue = cardPayoutData[consecutiveCount];
                    const betPerLine = (baseSpinCost * betMultiplier) / paylines.length;
                    const lineWin = payoutMultiplierValue * betPerLine;
                    totalWinnings += lineWin;
                    winningPaylinesDetails.push({
                        paylineIndex: paylineIndex,
                        coords: paylineCoords.slice(0, consecutiveCount),
                        symbol: firstSymbol,
                        count: consecutiveCount
                    });
                }
            });
            return { totalWinnings: parseFloat(totalWinnings.toFixed(2)), winningPaylines: winningPaylinesDetails };
        }

        function highlightWinningCells(winningPaylinesData) {
            winningPaylinesData.forEach(winData => {
                winData.coords.forEach(coord => {
                    if(reelCells[coord.col] && reelCells[coord.col][coord.row]) {
                        const cell = reelCells[coord.col][coord.row];
                        cell.classList.add('winning');
                        // Trigger sparkles for each winning cell
                        const cellRect = cell.getBoundingClientRect();
                        const containerRect = slotMachineContainer.getBoundingClientRect(); // Use this if particles are appended to slotMachineContainer
                        const relX = cellRect.left - containerRect.left + cellRect.width / 2;
                        const relY = cellRect.top - containerRect.top + cellRect.height / 2;
                        triggerSparkleExplosion(relX, relY, 5, slotMachineContainer); // 5 sparkles per winning cell
                    }
                });
            });
        }

        // --- Initialize Game ---
        document.addEventListener('DOMContentLoaded', initializeGame);
    </script>
</body>
</html>
```

I hope you find these enhancements make the game significantly more captivating! Let me know your thoughï¿½