<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - Dynamic DOM Texture (Character Fill)</title>
    <style>
        /* Basic reset and full viewport setup */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #0d0f12; /* Match user's background */
            color: #fff;
        }

        #webgl-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Container for the characters - Position offscreen for capture */
        #character-container {
            position: absolute;
            left: -9999px; /* Position offscreen */
            top: 0px;
             /* Define a fixed size for consistent texture quality/performance */
            width: 1024px; /* e.g., 1k texture width */
            height: 1024px;/* e.g., 1k texture height */
            font-family: monospace; /* CRUCIAL */
            white-space: pre;
            overflow: hidden;
            font-size: 16px; /* Adjust for texture detail */
            line-height: 1.1;
            color: #93638a; /* Match user's color */
            background-color: #0d0f12; /* Match body background for seamless texture */
            /* Ensure background is opaque */
        }

        /* Helper element for measuring (kept off-screen) */
        #measure-span {
            position: absolute;
            /* Use visibility: hidden instead of offscreen pos if preferred */
            left: -9999px;
            top: 0;
            visibility: hidden;
            height: auto;
            width: auto;
            white-space: nowrap;
            /* Apply same font styles */
             font-family: monospace;
             font-size: 16px;
             line-height: 1.1;
        }
    </style>
</head>
<body>
    <!-- Three.js Canvas Container -->
    <div id="webgl-container"></div>

    <!-- Offscreen DOM Elements for Character Generation & Capture -->
    <span id="measure-span"></span>
    <div id="character-container"></div> <!-- Content generated by JS -->

    <!-- ======================= -->
    <!-- JavaScript Starts Here  -->
    <!-- ======================= -->

    <!-- CDN Include for html2canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Import Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <!-- Combined Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // html2canvas loaded via script tag above, available globally

        // --- DOM Character Fill Logic (from user code) ---
        const container = document.getElementById('character-container');
        const measureSpan = document.getElementById('measure-span');
        const mandarinChars = "伤孑閹羪螜臱佈忇軅亇亇贔颗亇蛧砏汱宂彶泠屮噻蟣櫻鴈烪泠苶风亇泠厏蹗萺烪莟螜苶屮颗孑风鬀鎌孑跏穿孑风皿屮閹彶蟡蜫佈丝繣亇泠圑閹亇蜫砏宂乓梓亇亇螜櫻驕鴈灺泠皿孑泠泠忇軅萺芙彶鏍苶风疀亇亇靡鴈风矮穿泠风矢亇虀莟蜫蛧佈汱鱇忇风軅驕亇颗砏拧円诩亇泠繋圑虀輮佈灪伤孑亇风亇圑蟡矢繋羪苶亇噻亇泠颗蛧风蚶穿亇风厏孑驕伤臱蟡梓矢颗宂风櫻灪孑靡彶屮烪紾亇孑彶亇閹蚶绾驕耸孑孑风孑贔蛧対螜彶矢屮蚶泠风声亇櫻佈蟣潇鏍烪櫻皿泠孑亇风屮窵弔蚶螜伤孑靡屮屮軅鱇风臱咮厏皿砏宂泠窵泠圑臱鏍泠繋穿泠风弔亇僮矮靡閹蚶皿屮穿孑孑孑汱泠蛧莟羪窵灺屮僮亇泠泠臱孑潇绾穿矢鏍宂风臱屮孑鬀羪风绾皿拧泠梓屮櫻噻嚲櫻輮円泠乓壭亇贔皿藕疀跏咮臱灺屮泠亇屮亇嚲厏蓁繋紾厏蟡丝泠驕軅泠鱇跏亇佈诩宂屮矮风灪蜫窵屮輮円孑宂乓风藕梓蹗潇鎌莟繣诩亇亇孑孑风蜫皿噻螜灺丝颗拧亇軅僮孑鱇绾対诩砏厏孑蟡泠圑靡鴈风蚶芙泠风皿泠灪繋驕閹輮伤泠紾风孑孑厏孑疀莟螜窵莟拧繣亇屮屮虀屮鬀羪穿弔矮汱亇颗屮孑鱇蚶孑鏍弔忇泠莟泠灪萺鬀僮萺紾风円丝孑风芙亇嚲绾繋颗梓风贔孑屮风靡対颗矮烪苶噻汱亇蟣亇泠蟣矮屮跏诩対屮繋孑藕蜫潇泠噻弔亇声乓屮屮莟贔颗鎌彶驕莟风亇孑亇屮颗芙疀螜耸汱潇対拧矢屮軅羪灪鱇窵砏孑咮厏屮屮円孑繣鏍鱇虀噻伤亇诩対孑孑紾孑虀螜蜫驕鴈芙屮円対孑屮灺亇閹萺鴈蹗鎌声泠対厏屮贔砏泠鬀噻羪圑跏厏孑屮声风櫻跏僮鬀噻莟亇梓宂泠孑穿泠蟣矮靡鱇鴈紾屮紾丝屮泠弔泠閹蚶蛧蟣螜苶泠矢丝屮孑诩风靡輮蚶櫻矮汱风壭対风軅佈藕臱鴈彶藕彶宂亇孑乓亇繣绾蟣靡鴈诩屮灺壭风泠苶孑鱇繋潇鬀螜芙泠芙忇泠亇皿亇靡鎌噻虀鎌声风汱壭风泠伤屮颗螜繋僮跏宂孑孑宂亇蹗梓蹗潇輮佈軅佈壭泠泠汱风虀彶閹颗螜烪泠伤拧亇亇矢泠靡羪疀靡鎌苶风苶拧孑风芙泠颗鏍輮鱇繋厏孑丝忇亇藕伤圑嚲蚶绾繣彶壭亇泠丝泠繣莟繣嚲蚶耸灪耸拧风亇厏亇閹咮臱潇鎌皿贔弔孑屮风声孑颗跏窵臱矮声孑乓孑屮屮円亇嚲矮鏍閹跏宂亇拧风泠蹗烪灪疀鏍砏驕佈拧屮亇壭孑虀耸虀疀鏍伤蹗诩忇苶泠贔蚶亇櫻靡鎌孑鴈紾対対彶宂亇鬀屮亇灪噻拧蓁绾诩矢蓁円亇屮屮孑屮嚲紾颗蟡矮皿蹗伤孑亇泠声泠虀鏍鱇蟣蛧灺亇佈矢忇泠砏孑圑臱繣风鱇绾风羪莟芙屮蛧拧风圑軅屮軅螜弔鎌輮佈壭櫻厏屮亇屮乓风蜫繋萺閹蚶声屮苶対泠屮佈屮驕蜫蛧亇蓁烪亇弔伤厏孑窵屮亇櫻潇风鬀彶円诩鎌紾泠僮屮屮屮鱇汱繣鴈绾佈靡砏风风屮忇亇櫻梓藕臱蟡跏屮矮声泠忇紾孑屮蟡亇藕鱇鎌孑萺诩矢対矮厏风驕屮亇圑蟡厏蓁矮梓矢臱芙泠屮屮孑孑潇莟颗疀蚶弔泠诩忇屮屮皿亇驕萺鱇蹗蜫莟孑砏芙対屮繋风屮虀繣泠蟣跏対羪彶紾屮颗忇亇亇軅屮圑鴈灺鎌窵彶丝贔厏泠屮屮芙泠颗螜萺繣輮苶屮苶声孑亇羪屮櫻靡蓁孑疀诩丝弔梓声风潇亇屮藕颗泠閹羪烪诩噻伤亇圑亇泠风虀円僮蟡矮佈驕咮忇风屮厏泠灪跏藕鱇疀跏亇鏍壭円风亇噻孑贔櫻窵亇臱彶伤伤蟡灺孑孑屮屮亇蹗莟屮鬀疀蚶风蟡弔丝円佈苶风閹风屮泠鱇対蹗萺羪跏鱇矮対屮汱声风屮蚶孑藕繣嚲亇閹彶皿梓輮莟屮圑忇孑亇圑烪屮靡蛧蟡贔蓁紾孑烪灺苶亇嚲风风孑繣拧圑萺彶蚶颗鎌汱屮穿厏风泠跏亇軅虀鬀亇蟣绾苶跏鏍莟风櫻厏屮泠孑穿风靡萺蜫灪蜫伤孑梓烪苶屮窵风孑泠軅风泠噻莟噻疀鎌矢屮紾丝亇风佈屮軅鬀驕亇繣羪厏鎌跏莟丝鱇矢泠孑孑汱亇靡蚶鬀驕蜫耸孑绾弔矢屮螜丝孑藕亇泠亇窵伤蜫窵鎌芙泠耸壭泠风诩风軅嚲軅孑繣鏍忇萺彶耸汱颗芙泠风孑壭风閹羪驕鱇蜫砏孑矮芙汱忇繋厏孑櫻亇泠孑蓁円靡萺鏍伤灪砏壭亇泠皿屮圑蛧屮贔繣螜泠蓁砏诩穿蓁紾泠泠风孑泠蟣砏灪靡疀跏亇螜芙宂厏咮乓泠虀孑亇孑潇乓_輮繋梓蟣绾壭孑拧矢亇屮鴈亇藕驕蟡泠潇丝芙丝泠疀风泠屮靡壭蹗鴈矮矮蟣輮声亇皿弔声泠疀屮风泠灪壭风蓁鏍蓁蟣疀烪亇咮烪皿屮疀汱风孑亇壭孑靡鎌蟣繣靡彶亇輮耸伤汱疀紾泠泠风丝屮櫻蚶屮蹗驕鴈亇潇咮灺伤疀砏亇屮壭宂亇亇蚶孑藕蹗颗屮僮矮莟繋疀鏍厏屮芙汱丝孑鎌风亇藕蹗屮屮萺梓蛧嚲萺皿屮佈矢汱风鎌宂孑贔屮亇风嚲佈虀颗疀砏屮蚶皿矢厏鎌円泠泠孑孑泠驕佈泠鬀颗螜屮蜫灺穿烪鎌灺孑泠拧泠屮泠梓屮驕閹潇屮虀彶円羪螜彶壭泠穿风屮屮梓屮軅虀櫻屮軅蚶芙窵鴈鏍円泠梓丝风孑梓忇亇蟣泠亇孑蓁芙鱇蟡鴈梓泠鏍声忇対佈声泠驕亇风风鱇芙圑疀蟡鎌泠蛧皿壭紾砏弔泠驕风亇风圑円风靡蓁嚲泠靡莟丝跏咮耸拧蟣苶屮亇泠円孑驕疀僮屮繣繋丝蟡跏咮苶蟣灺亇泠亇芙亇圑蜫风孑藕蟡丝鬀鏍羪耸蟣羪丝屮宂皿宂亇蜫屮屮亇鬀丝軅宂皿汱风靡屮屮泠僮穿屮颗蜫疀孑鱇砏矢鏍鎌羪汱屮灺丝壭亇跏宂屮圑风亇孑靡彶軅鱇鱇鎌风颗砏莟耸嚲羪忇亇声苶汱亇疀屮风风藕厏泠颗窵靡圑蟣彶対萺繋羪苶軅佈壭风亇梓汱亇櫻泠孑孑虀莟屮鬀鬀萺孑鬀砏伤彶窵矮宂亇皿乓汱屮萺忇孑屮孑忇孑臱輮驕蹗蟣羪风蓁绾绾弔驕绾壭屮丝伤声风虀泠风孑僮紾屮靡颗疀孑虀咮皿矮鴈矮汱屮诩対対屮鏍対孑亇孑屮风鬀矮軅繣蟣鎌孑颗彶砏灺靡繋丝屮声皿声亇臱屮亇屮藕苶泠靡疀靡亇驕绾声鴈鎌矮苶泠佈宂丝亇绾乓孑圑风屮泠虀咮屮虀虀萺孑閹彶莟咮蜫鏍宂屮皿苶声屮蓁忇泠风亇対孑靡蟡蟣圑繣繋宂蓁繋繋弔蹗绾宂风壭梓矢泠櫻泠孑泠僮灺屮閹鬀蓁亇蟣彶伤矮蟡鎌汱泠诩乓乓屮鴈対泠屮孑拧屮閹螜灪蹗繣鎌孑颗跏跏灺蟣矮宂泠乓伤苶孑鱇泠泠风藕弔泠対紾苶亇蟣亇亇风泠耸孑櫻僮僮孑风蟡绾鬀閹鬀彶泠蓁咮绾烪驕鏍対拧苶梓烪孑藕宂风亇亇跏风泠泠贔泠屮嚲蚶僮櫻僮鏍壭靡鏍蚶佈藕噻穿汱紾繋佈泠风矢壭宂孑螜忇亇亇泠丝孑鱇蛧圑屮贔噻矢驕噻蛧羪泠蜫伤皿梓鴈繋壭亇弔声苶泠蓁汱风风屮苶风蹗靡风孑屮嚲紾軅嚲臱螜孑閹砏耸跏蜫鴈乓泠莟弔烪屮鬀芙屮亇孑烪忇屮繣屮屮孑閹佈孑虀驕蛧泠僮矮跏蚶閹蓁皿亇绾梓佈丝僮诩孑风风砏乓孑贔亇孑泠櫻矮风灪藕颗孑贔萺螜窵蹗靡耸対鎌羪繋声泠咮対汱拧矮皿风屮孑忇亇贔萺屮亇泠蟣対屮蜫蓁潇屮繣绾穿蟡輮鴈弔孑矮穿芙汱噻灺屮风拧乓宂屮嚲亇风亇灪円亇閹靡鱇风圑鎌诩嚲疀疀耸泠萺伤灺円潇彶孑屮厏弔苶孑虀孑亇风亇灺风櫻繣蹗亇泠蟡彶鱇鬀鬀绾孑疀砏绾伤虀鎌対风穿莟烪风灪対风屮孑彶泠厏烪皿泠蹗宂孑孑风繋风风屮屮壭屮驕蜫风泠亇潇烪亇臱虀蓁亇軅鏍羪窵蟣鬀莟丝噻繋螜弔孑螜穿皿円噻绾亇孑穿芙皿风虀声屮屮风砏丝风亇亇亇孑僮蟡泠亇亇閹苶屮颗鬀臱亇贔鎌砏潇靡鬀砏亇蜫绾鎌耸藕噻穿矢伤蚶羪拧亇烪矢皿孑颗芙泠孑泠诩厏泠藕孑孑孑軅蚶屮贔泠繣対屮颗潇蟣屮屮輮灺鱇潇鬀羪屮臱彶繋咮繣蛧円厏砏羪羪丝屮莟乓円孑蛧烪泠风屮皿乓亇僮风风孑泠绾屮圑亇藕风风臱蛧灪亇屮噻皿櫻疀臱蚶泠虀彶彶矮鬀疀皿拧繋咮羪乓泠彶厏矢宂輮灺泠泠壭矢声泠閹拧屮亇泠莟泠圑圑孑风屮鬀鴈屮圑屮蓁声圑蛧潇噻风繣彶莟萺潇蜫烪风輮梓跏円蹗矮厏汱矢繋梓亇风乓厏声泠嚲対风风屮紾风圑蹗风风亇虀矮亇灪泠颗丝亇蛧蓁蜫孑蹗跏烪疀蛧蜫耸孑窵耸咮烪虀蚶厏壭弔彶佈泠风芙丝乓风噻矢汱伤伤孑泠矢风汱亇蟡苶泠泠泠紾乓屮圑风泠风亇噻屮亇泠孑皿屮灪灪亇屮泠蟣鴈泠屮风虀芙亇閹繣驕孑风蛧螜蹗軅泠噻穿藕疀閹蟡亇軅鏍鎌蓁僮繣咮苶潇萺嚲砏泠颗佈羪彶驕嚲皿声繋鎌鴈苶风鎌紾砏穿虀鎌対厏皿繋跏孑孑伤苶伤亇鱇灺屮壭风跏烪屮屮壭汱矢亇閹対孑亇亇彶対屮孑屮宂忇贔靡风孑泠藕咮屮藕风贔忇风鱇颗孑孑屮臱砏屮驕圑臱拧屮蓁"; // Shortened for brevity if needed, but using full one
        let A = Math.random();
        let B = Math.random();
        let C = Math.random();
        let D = Math.random()*2;

        function debounce(func, wait) {
             let timeout;
             return function executedFunction(...args) {
                 const later = () => {
                     clearTimeout(timeout);
                     func(...args);
                 };
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
             };
         }

        function getCharSize() {
            // Apply container's computed styles to measure span
            const containerStyle = window.getComputedStyle(container);
            measureSpan.style.fontFamily = containerStyle.fontFamily;
            measureSpan.style.fontSize = containerStyle.fontSize;
            measureSpan.style.lineHeight = containerStyle.lineHeight;
            measureSpan.textContent = '字'; // Use a representative character

            const rect = measureSpan.getBoundingClientRect();
            measureSpan.textContent = ''; // Clear

            if (!rect.width || !rect.height) {
                 console.warn("Could not measure character size accurately. Using estimated defaults.");
                 const fontSize = parseFloat(containerStyle.fontSize) || 16;
                  // Use line height for height if available and valid, otherwise estimate
                 const lineHeight = parseFloat(containerStyle.lineHeight);
                 const height = (lineHeight && !isNaN(lineHeight)) ? fontSize * lineHeight : fontSize * 1.2;
                 return { width: fontSize, height: height }; // Rough estimate
            }
             // Use measured height - but divide by 2 was likely incorrect? Let's use full height.
            return { width: rect.width, height: rect.height };
        }

         function fillScreen() {
            // Update pseudo-random constants
            A = (D*(0.05-C)+B*0.001)%10;
            B = ((D+A*0.001))%10;
            C = (B*(0.05-A)+D)%10;
            D += (0.1)%10;

            const { width: charWidth, height: charHeight } = getCharSize();
    
            if (!charWidth || !charHeight || charWidth <= 0 || charHeight <= 0) {
                console.error("Character dimensions are invalid (<= 0). DOM update skipped.");
                // Avoid clearing content if measurements fail intermittently
                // container.textContent = "Error: Invalid character size measured.";
                return;
            }

             // Use the container's actual dimensions for calculation, not viewport
             // This ensures the offscreen div is filled appropriately for its size
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            const cols = Math.floor(containerWidth / charWidth);
            const rows = Math.floor(containerHeight / charHeight);

            if (cols <= 0 || rows <= 0) {
                console.warn("Calculated columns or rows for container are zero or less.");
                container.textContent = ''; // Clear container
                return;
            }

            let content = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const randomIndex = Math.abs(Math.floor(
                         (i*A*Math.sin(D*j)+ B*i*Math.cos(C*i)+1)
                     ))% mandarinChars.length;

                     // Basic check to avoid adding 'undefined' if index is somehow out of bounds
                    if (typeof mandarinChars[randomIndex] !== 'undefined') {
                       content += mandarinChars[randomIndex];
                    } else {
                       content += '?'; // Placeholder for safety
                    }
                }
                if (i < rows - 1) {
                    content += '\n';
                }
            }
            container.textContent = content;
        }

        // --- Three.js Setup ---
        let scene, camera, renderer, controls;
        let sphere, sphereMaterial, canvasTexture;
        const sphereRadius = 100;

        // Offscreen canvas for the texture
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 64; // Initial small size
        textureCanvas.height = 64;
        const textureContext = textureCanvas.getContext('2d', { alpha: false }); // No alpha needed if bg matches
        textureContext.fillStyle = '#0d0f12'; // Match background
        textureContext.fillRect(0, 0, textureCanvas.width, textureCanvas.height);

        // Texture update state flag
        let isTextureUpdating = false;

        function initThree() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('webgl-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xaaaaaa);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 2.5, 1000); // Slightly brighter
            pointLight.position.set(150, 100, 200);
            scene.add(pointLight);

            // Texture
            canvasTexture = new THREE.CanvasTexture(textureCanvas);
            canvasTexture.colorSpace = THREE.SRGBColorSpace; // Correct colorspace

            // Sphere
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 32);
            sphereMaterial = new THREE.MeshStandardMaterial({
                map: canvasTexture, // Apply texture immediately (it has placeholder)
                color: 0xffffff, // Base color if texture fails (or before load)
                metalness: 0.1, // Less metallic
                roughness: 0.8, // More rough
            });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);

            // --- Start DOM Content Update Interval (from user code) ---
             // Initial fill called via 'load' listener below
            setInterval(() => {
                 if (document.body.contains(container)) { // Check if exists
                     fillScreen();
                 }
             }, 200); // DOM update frequency (ms)

            // --- Start Texture Update Interval ---
            setInterval(() => {
                 // Only trigger if the previous update finished
                 // and the container exists in the DOM
                 if (!isTextureUpdating && document.body.contains(container)) {
                    updateTextureFromDOM();
                 }
            }, 400); // Texture update frequency (ms) - less frequent than DOM update


            // --- Event Listeners ---
             window.addEventListener('resize', onWindowResize); // Handles both DOM and Three.js resize indirectly

             // Initial DOM fill on load (from user code)
             window.addEventListener('load', () => {
                 console.log("Window loaded, running initial fillScreen.");
                 fillScreen();
                 // Optionally run initial texture update after a short delay
                 // setTimeout(updateTextureFromDOM, 100); // e.g., 100ms after load->fillScreen
             });


            // Start Animation Loop
            animate();
        }

        // --- Function to capture DOM and update texture ---
        function updateTextureFromDOM() {
            // console.log("Attempting texture update..."); // Debug log
            isTextureUpdating = true; // Set flag

            const options = {
                scale: 1, // Start with 1x scale for performance, increase if needed (e.g., 1.5 or 2)
                useCORS: true,
                logging: false,
                backgroundColor: '#0d0f12' // Explicitly set background
                // Ensure width/height match the CSS of #character-container if needed
                // width: 1024,
                // height: 1024
            };

            html2canvas(container, options).then(renderedCanvas => {
                // Draw the result onto our persistent textureCanvas
                // Resize canvas first if needed (if html2canvas result size varies)
                if (textureCanvas.width !== renderedCanvas.width || textureCanvas.height !== renderedCanvas.height) {
                    textureCanvas.width = renderedCanvas.width;
                    textureCanvas.height = renderedCanvas.height;
                }
                textureContext.drawImage(renderedCanvas, 0, 0);

                // Update the Three.js texture
                canvasTexture.needsUpdate = true;
                // console.log("Texture updated."); // Debug log
                isTextureUpdating = false; // Clear flag

            }).catch(error => {
                 console.error("html2canvas error:", error);
                 isTextureUpdating = false; // Clear flag even on error
            });
        }

        // --- Resize Handler ---
        // Debounced resize handler from user code already handles calling fillScreen
        // We just need to update Three.js camera/renderer here
        const debouncedFillScreen = debounce(fillScreen, 250); // Use debounce from user code

        function onWindowResize() {
            // Update camera aspect ratio and renderer size
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

             // Also trigger the DOM recalculation/fill (debounced)
             // This will resize the offscreen div content based on viewport calculations
             // Note: This might cause texture stretching if offscreen div size is fixed.
             // Consider if fillScreen should use fixed container size instead.
             // Let's keep user's logic for now.
            debouncedFillScreen();

            // No need to directly call updateTextureFromDOM here,
            // the interval timer will handle it after fillScreen updates the DOM.
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update orbit controls
            renderer.render(scene, camera);
        }

        // --- Initialize ---
        initThree(); // Start the Three.js part

    </script>

</body>
</html>