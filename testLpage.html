<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>L-Systems: A Manifesto for 2025</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root{
            --bg:#f4f1eb; --text:#2a2a2a; --accent:#4a6c6f; --accent2:#c9a27b;
        }
        body{background:var(--bg); color:var(--text); font-family:Inter,system-ui,Segoe UI,Roboto,Arial; margin:0;}
        .prose-custom h1,.prose-custom h2,.prose-custom h3{font-family:Lora,serif; color:var(--text);}
        .sticky-canvas-container{position:sticky; top:5vh; height:90vh; display:flex; align-items:center; justify-content:center;}
        .canvas-wrap{width:100%; height:100%; display:flex; flex-direction:column; gap:8px;}
        #l-system-canvas{width:100%; height: calc(100% - 64px); background:linear-gradient(180deg,#ffffff,#f0ebe4); border-radius:8px; box-shadow:0 6px 24px rgba(0,0,0,0.08); display:block;}
        .control-panel{height:64px; display:flex; gap:8px; align-items:center; padding:6px 4px;}
        .control-panel input[type="text"], .control-panel input[type="number"]{padding:6px 8px; border-radius:6px; border:1px solid rgba(0,0,0,0.08); background:white;}
        .control-panel button{background:var(--accent); color:white; padding:8px 12px; border-radius:6px; border:none; cursor:pointer;}
        .control-panel button:focus,.control-panel input:focus{outline:3px solid rgba(74,108,111,0.12);}
        @media (max-width: 900px){
            .sticky-canvas-container{position:static; height: 48vh; margin-top:12px;}
            #l-system-canvas{height:100%;}
        }
        @media (prefers-reduced-motion: reduce){
            *{transition:none!important; animation:none!important;}
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Lora:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container mx-auto px-4 py-8 md:py-16">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-8 lg:gap-16">
            <div id="text-column" class="md:col-span-1 lg:col-span-2 prose prose-custom max-w-none overflow-y-auto h-[90vh] pr-4">
                <section data-trigger="intro">
                    <h1 class="text-4xl font-bold">Why L-Systems Still Matter in 2025</h1>
                    <p class="text-lg text-gray-600 mb-8">(And Why I’m Building a New Studio)</p>
                    <p>Every so often, computing circles back to its unfinished business. To the strange loops and beautiful dead ends. Fractals. Cellular automata. Artificial life. Entire branches of computational exploration that once lit up the late 20th century, only to recede into the background as the brute force of industry demanded a different kind of efficiency.</p>
                    <p>L-systems—those recursive, string-rewriting engines first devised to model the quiet, relentless growth of algae—are one of those forgotten futures. They are a formalism that compresses the baroque complexity of a fern into a grammar you could write on a napkin. Data, order, poetry.</p>
                </section>

                <section data-trigger="history">
                    <h2 class="font-lora">A Short History of Unfinished Business</h2>
                    <p>L-systems began not in code, but in life. In 1968, the biologist Aristid Lindenmayer needed a language for growth itself. The result was a formal grammar, a way to describe not a static object, but a developing one. It was a profound shift in perspective. Then came the graphics researchers, and the 1990 book <em>The Algorithmic Beauty of Plants</em>, which revealed the sheer aesthetic power of these simple rules.</p>
                    <p>For a time, the most tangible embodiment of this was <strong>LStudio</strong>, a research tool from the University of Calgary. It wasn't slick. It wasn't for consumers. But it worked. It was a direct interface with the theory. And then, for decades, nothing truly took its place. That absence is the reason for this project.</p>
                </section>

                <section data-trigger="mechanics_string">
                    <h2 class="font-lora">The Grammar of Growth</h2>
                    <p>At their core, L-systems are brutally, elegantly simple. They are not about learning; they are about unfolding. Every system is just three things: an <strong>Axiom</strong> (the seed), <strong>Production rules</strong> (the physics of its tiny universe), and an <strong>Iteration count</strong> (time).</p>
                    <p>Watch how one of Lindenmayer's original algae models expands. It's not random. It's a deterministic explosion of order, a cascade of substitutions that builds complexity from the ground up.</p>
                </section>

                <section data-trigger="mechanics_turtle">
                    <h3 class="font-lora">Turtle Graphics: Giving Symbols a Body</h3>
                    <p>The genius was in translation. The leap from abstract string to physical form came via turtle graphics, where each symbol becomes a command: move, turn, remember, return. The standard alphabet is a language of movement:</p>
                    <ul>
                        <li><code>F</code> — move forward and draw</li>
                        <li><code>f</code> — move forward without drawing</li>
                        <li><code>+</code>/<code>-</code> — turn right/left by angle</li>
                        <li><code>[</code>/<code>]</code> — push / pop state (branching)</li>
                    </ul>
                    <p>Those brackets—<code>[</code> and <code>]</code>—are the secret to branching. They are memory. They are recursion made manifest. A way for the turtle to explore a path and then return, precisely, to where it was before. Try it. Change a rule, an angle. See what universe you can grow.</p>
                </section>

                <section data-trigger="mechanics_koch">
                     <h3 class="font-lora">Beyond Biology: The Koch Curve</h3>
                    <p>The same grammar that grows a plant can also etch the infinite coastline of a fractal. The Koch snowflake is an L-system, a perfect, crystalline structure born from the same simple process of recursive substitution.</p>
                </section>

                <section data-trigger="conclusion">
                    <h2 class="font-lora">Let's Grow Something</h2>
                    <p>This project is a gesture against the black box. Against the drift toward computational systems that are ever more powerful but ever less scrutable. L-systems are the opposite: they are generative systems you can read. They are interpretable by design.</p>
                </section>
            </div>

            <div class="md:col-span-1 lg:col-span-3">
                <div class="sticky-canvas-container flex flex-col items-center justify-center bg-white/30 rounded-lg shadow-lg p-4 backdrop-blur-sm">
                    <div class="canvas-wrap w-full h-full">
                        <canvas id="l-system-canvas" role="img" aria-label="L-system visualization" tabindex="0"></canvas>
                        <div class="control-panel" aria-live="polite">
                            <input id="axiom" type="text" title="axiom" placeholder="Axiom (e.g. F)" value="F">
                            <input id="rules" type="text" title="rules" placeholder='Rules (F=F[+F]F)' value="F=F[+F]F">
                            <input id="iterations" type="number" min="0" max="8" title="iterations" value="4" style="width:80px;">
                            <input id="angle" type="number" min="0" max="180" title="angle" value="25" style="width:72px;">
                            <button id="generate-btn">Generate</button>
                            <button id="reset-btn">Reset</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function(){
        const canvas = document.getElementById('l-system-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const axInput = document.getElementById('axiom');
        const rulesInput = document.getElementById('rules');
        const iterInput = document.getElementById('iterations');
        const angleInput = document.getElementById('angle');
        const genBtn = document.getElementById('generate-btn');
        const resetBtn = document.getElementById('reset-btn');
        const textColumn = document.getElementById('text-column');

        // helpers: resize canvas correctly and use setTransform to avoid cumulative scale
        function resizeCanvas(){
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const rect = canvas.getBoundingClientRect();
            const w = Math.max(1, Math.floor(rect.width));
            const h = Math.max(1, Math.floor(rect.height));
            canvas.width = Math.floor(w * dpr);
            canvas.height = Math.floor(h * dpr);
            // reset transform and scale once per draw
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            // redraw current scene
            drawScene(currentScene, true);
        }

        // Simple L-system generator
        function generateLSystem(axiom, rulesText, iterations){
            const rules = new Map();
            // support single-line "A=AB;B=A" or a single "F=..." string
            rulesText.split(/;|\n/).map(s=>s.trim()).forEach(line=>{
                if(!line) return;
                const idx = line.indexOf('=');
                if(idx<0) return;
                const left = line.slice(0,idx).trim();
                const right = line.slice(idx+1).trim();
                if(left) rules.set(left, right);
            });
            let result = axiom;
            for(let i=0;i<Math.max(0,Math.floor(iterations));i++){
                let next = '';
                for(let j=0;j<result.length;j++){
                    const ch = result[j];
                    if(rules.has(ch)) next += rules.get(ch);
                    else next += ch;
                }
                result = next;
                if(result.length > 500000) break; // safety
            }
            return result;
        }

        // Turtle drawer for 2D
        function drawTurtle(str, opts = {}){
            const { startX, startY, length, angleDeg, strokeStyle } = opts;
            ctx.clearRect(0,0, canvas.width, canvas.height);
            // coordinate system: origin top-left, positive Y down; we'll map turtle Y-up to -Y canvas
            ctx.save();
            // center transform for nicer framing
            ctx.translate(startX, startY);
            ctx.scale(1, -1); // invert Y so turtle treats +Y as 'up'
            ctx.lineWidth = Math.max(0.5, Math.min(6, (length * 0.12)));
            ctx.strokeStyle = strokeStyle || '#2c6b6b';
            ctx.beginPath();
            let x = 0, y = 0;
            let ang = Math.PI/2; // facing up
            const stack = [];
            ctx.moveTo(x,y);
            for(let i=0;i<str.length;i++){
                const c = str[i];
                if(c === 'F' || c === 'G'){
                    const nx = x + length * Math.cos(ang);
                    const ny = y + length * Math.sin(ang);
                    ctx.lineTo(nx, ny);
                    x = nx; y = ny;
                } else if(c === 'f'){
                    const nx = x + length * Math.cos(ang);
                    const ny = y + length * Math.sin(ang);
                    ctx.moveTo(nx, ny);
                    x = nx; y = ny;
                } else if(c === '+'){
                    ang -= (angleDeg * Math.PI / 180);
                } else if(c === '-'){
                    ang += (angleDeg * Math.PI / 180);
                } else if(c === '['){
                    stack.push({x, y, ang});
                } else if(c === ']'){
                    const s = stack.pop();
                    if(s){ x = s.x; y = s.y; ang = s.ang; ctx.moveTo(x,y); }
                } else {
                    // ignore other symbols
                }
                // safety yield for very long strings (avoid blocking for extremely large data)
                // not implemented here because draw is fast for reasonable strings
            }
            ctx.stroke();
            ctx.restore();
        }

        // Koch fractal drawer (simple)
        function generateKoch(iterations){
            // initial line segment represented as string using characters F and angle markers
            let ax = "F";
            const rule = { 'F': "F+F--F+F" };
            let cur = ax;
            for(let i=0;i<iterations;i++){
                let next = '';
                for(let ch of cur){
                    next += rule[ch] || ch;
                }
                cur = next;
                if(cur.length > 200000) break;
            }
            return cur;
        }

        // Scenes logic
        const scenes = {
            intro: {
                setup(){ /* animated gentle growth */ },
                render(){
                    // simple ambient plant growth over time
                    const ax = "F";
                    const rules = "F=F[+F]F[-F]F";
                    const t = Math.floor((Date.now()/600) % 6) + 1; // 1..6 iterations
                    const s = generateLSystem(ax, rules, t);
                    const len = Math.max(2, (canvas.getBoundingClientRect().height / 200) * (6 / (t+1)) );
                    drawTurtle(s, { startX: canvas.width/2/Math.max(1,window.devicePixelRatio), startY: canvas.getBoundingClientRect().height*0.1, length: len, angleDeg: 22, strokeStyle:'#2c6b6b' });
                }
            },
            history:{
                render(){
                    // static decorative plant
                    const s = generateLSystem("F", "F=F[+F]F", 4);
                    const len = Math.max(1.8, (canvas.getBoundingClientRect().height / 180));
                    drawTurtle(s, { startX: canvas.width/2/Math.max(1,window.devicePixelRatio), startY: canvas.getBoundingClientRect().height*0.12, length: len, angleDeg: 24, strokeStyle:'#6b4a3a' });
                }
            },
            mechanics_string:{
                render(){
                    // show string expansion visually as text (drawn on canvas)
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.save();
                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.fillStyle = '#2a2a2a';
                    ctx.font = '14px Inter, sans-serif';
                    const ax = "A";
                    const rules = "A=AB;B=A";
                    const it = 6;
                    let s = generateLSystem(ax, rules, it);
                    // render only first N chars
                    const rect = canvas.getBoundingClientRect();
                    const padding = 12;
                    ctx.fillText("Expanded string (truncated):", padding, 20);
                    const maxChars = 600;
                    const show = s.length > maxChars ? s.slice(0, maxChars) + '…' : s;
                    const charsPerLine = 60;
                    for(let i=0;i<Math.ceil(show.length/charsPerLine);i++){
                        const chunk = show.slice(i*charsPerLine, (i+1)*charsPerLine);
                        ctx.fillText(chunk, padding, 44 + i*18);
                    }
                    ctx.restore();
                }
            },
            mechanics_turtle:{
                render(){
                    // draw using current controls
                    const ax = axInput.value || "F";
                    const rules = rulesInput.value || "F=F[+F]F";
                    const it = parseInt(iterInput.value,10) || 4;
                    const angle = parseFloat(angleInput.value) || 25;
                    const s = generateLSystem(ax, rules, it);
                    const bbox = canvas.getBoundingClientRect();
                    const len = Math.max(1.2, (bbox.height / 200) * (6 / (it+1)));
                    drawTurtle(s, { startX: bbox.width/2, startY: bbox.height*0.08, length: len, angleDeg: angle, strokeStyle:'#2c6b6b' });
                }
            },
            mechanics_koch:{
                render(){
                    // draw Koch curve centered
                    const it = 4;
                    const s = generateKoch(it);
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.save();
                    const rect = canvas.getBoundingClientRect();
                    // map turtle to horizontal center
                    const length = Math.min(rect.width, rect.height) / (s.length / 2 + 10);
                    ctx.translate(rect.width/2, rect.height/2);
                    ctx.scale(1, -1);
                    ctx.strokeStyle = '#2c6b6b';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    let x= -rect.width/3, y=0;
                    let ang = 0;
                    ctx.moveTo(x,y);
                    for(let ch of s){
                        if(ch === 'F'){
                            const nx = x + length * Math.cos(ang);
                            const ny = y + length * Math.sin(ang);
                            ctx.lineTo(nx, ny);
                            x = nx; y = ny;
                        } else if(ch === '+'){
                            ang -= Math.PI/3;
                        } else if(ch === '-'){
                            ang += Math.PI/3;
                        }
                    }
                    ctx.stroke();
                    ctx.restore();
                }
            },
            conclusion:{
                render(){
                    // light decorative fade
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.save();
                    ctx.fillStyle = '#f8f6f3';
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.restore();
                }
            }
        };

        let currentScene = 'intro';
        let raf = null;
        let lastResize = 0;

        function drawScene(sceneName, isResize=false){
            currentScene = sceneName in scenes ? sceneName : 'intro';
            // cancel previous RAF to avoid stacking
            if(raf) { cancelAnimationFrame(raf); raf = null; }
            // for animated scenes (intro) use RAF loop; for others a single render is enough
            if(currentScene === 'intro'){
                function loop(){
                    scenes.intro.render();
                    raf = requestAnimationFrame(loop);
                }
                loop();
            } else {
                scenes[currentScene].render();
            }
        }

        // IntersectionObserver to change scenes based on visible section
        const observerRoot = textColumn;
        const observer = new IntersectionObserver((entries)=>{
            entries.forEach(entry=>{
                if(entry.isIntersecting){
                    const trigger = entry.target.getAttribute('data-trigger');
                    if(trigger) drawScene(trigger);
                }
            });
        }, { root: observerRoot, threshold: 0.5 });
        document.querySelectorAll('#text-column section').forEach(s => observer.observe(s));

        // controls
        genBtn.addEventListener('click', ()=>{
            // switch to mechanics_turtle when generating
            drawScene('mechanics_turtle');
        });
        resetBtn.addEventListener('click', ()=>{
            axInput.value = 'F';
            rulesInput.value = 'F=F[+F]F[-F]F';
            iterInput.value = 4;
            angleInput.value = 25;
            drawScene('intro');
        });

        // accessibility: keyboard triggers
        canvas.addEventListener('keydown', (e)=>{
            if(e.key === 'g') drawScene('mechanics_turtle');
            if(e.key === 'k') drawScene('mechanics_koch');
        });

        // initial resize + draw
        window.addEventListener('resize', () => { lastResize = Date.now(); resizeCanvas(); });
        // observe size changes of parent container to handle responsive height changes
        const ro = new ResizeObserver(() => { resizeCanvas(); });
        ro.observe(canvas);
        // initial call
        resizeCanvas();

        // ensure canvas is focusable on mobile when tapped
        canvas.addEventListener('pointerdown', ()=> canvas.focus());

        // keep an interval to update animated intro even if scrolled into view
        setInterval(()=> {
            if(currentScene === 'intro') scenes.intro.render();
        }, 700);
    })();
    </script>
</body>
</html>
