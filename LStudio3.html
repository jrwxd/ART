<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L-system Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/ccapture.js@1.1.0/build/CCapture.all.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111723;
        }
        #ui-panel {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        #ui-panel.hidden {
            transform: translateX(calc(100% + 20px));
            opacity: 0;
        }
        #toggle-button {
            transition: transform 0.3s ease-in-out;
        }
        #toggle-button.collapsed {
            transform: rotate(180deg);
        }
        /* Custom scrollbar */
        #ui-panel::-webkit-scrollbar { width: 8px; }
        #ui-panel::-webkit-scrollbar-track { background: #1f2937; border-radius: 10px; }
        #ui-panel::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        #ui-panel::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        #help-modal { transition: opacity 0.2s ease-in-out; }
        #help-modal-content { transition: transform 0.2s ease-in-out; }

        details > summary {
            cursor: pointer;
            list-style: none; /* Hide default marker */
        }
        details > summary::-webkit-details-marker {
            display: none; /* Hide default marker in Safari */
        }
        details summary .arrow {
            transition: transform 0.2s;
        }
        details[open] summary .arrow {
            transform: rotate(90deg);
        }
        #progress-overlay {
            z-index: 9999;
        }
        /* Color input styling */
        input[type="color"] {
            appearance: none;
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
        	padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
        	border: 1px solid #4b5563;
            border-radius: 8px;
        }
        /* Mobile-specific UI adjustments */
        @media (max-width: 640px) {
            #ui-panel { display: none !important; }
            #ui-panel.mobile-modal { display: block !important; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); width: calc(100% - 32px); max-width: 520px; max-height: calc(100vh - 80px); overflow-y: auto; z-index: 10000; }
            #ui-panel .space-y-4 { padding-bottom: 16px; }
            .mobile-fab { position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%); z-index: 10001; width: 64px; height: 64px; border-radius: 999px; display: flex; align-items: center; justify-content: center; background: linear-gradient(180deg,#111827,#1f2937); color: white; box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.06); }
            .mobile-fab svg { width: 28px; height: 28px; }
            /* Larger touch targets */
            #ui-panel input, #ui-panel textarea, #ui-panel select, #ui-panel button { font-size: 18px; padding: 10px; }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="container"></div>

    <!-- Progress overlay for video export -->
    <div id="progress-overlay" class="fixed inset-0 bg-black bg-opacity-70 items-center justify-center text-white text-2xl font-bold hidden">
        <span id="progress-text"></span>
    </div>

    <div id="ui-panel" class="absolute top-5 right-5 bg-gray-800 bg-opacity-80 backdrop-blur-sm text-white p-6 rounded-lg shadow-2xl w-full max-w-sm">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold">L-system Studio</h1>
            <div>
                <button id="help-btn" class="p-2 rounded-full hover:bg-gray-700 focus:outline-none" title="Help (M)">
                    <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.79 4 4 0 1.152-.448 2.213-1.175 3.016l-1.115 1.115a1 1 0 00-1.414 1.414l1.115-1.115a5.96 5.96 0 011.575-2.316A5.986 5.986 0 0020 13c0-3.314-2.686-6-6-6s-6 2.686-6 6c0 .69.106 1.35.305 1.956a1 1 0 101.94-.487A4 4 0 0112 11c-1.272 0-2.382.596-3.14 1.5A1 1 0 008.228 9zM12 18a1 1 0 100-2 1 1 0 000 2z" /></svg>
                </button>
                <button id="toggle-button" class="p-2 rounded-full hover:bg-gray-700 focus:outline-none" title="Toggle Panel (H)">
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                </button>
            </div>
        </div>

        <div class="space-y-4">
            <div id="palette-section">
                <label class="block text-sm font-medium text-gray-300 mb-1">Color Palette</label>
                <div id="palette-pickers" class="flex flex-wrap gap-2 mb-2"></div>
            </div>
            <div>
                <label for="presets" class="block text-sm font-medium text-gray-300">Presets</label>
                <select id="presets" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm p-2"></select>
            </div>

            <details open>
                <summary class="text-lg font-semibold py-2 flex justify-between items-center"><span>Structure System</span><span class="arrow">&#9654;</span></summary>
                <div class="space-y-4 pt-2 border-t border-gray-700">
                    <div><label for="axiom" class="block text-sm">Axiom</label><input type="text" id="axiom" class="mt-1 block w-full bg-gray-700 p-2 rounded-md"></div>
                    <div><label for="iterations" class="block text-sm">Iterations: <span id="iterations-value">6</span></label><input type="range" id="iterations" min="0" max="10" value="6" class="w-full h-2 bg-gray-700 rounded-lg"></div>
                    <div><label for="rules" class="block text-sm">Rules</label><textarea id="rules" rows="4" class="mt-1 block w-full bg-gray-700 p-2 rounded-md"></textarea></div>
                </div>
            </details>
            
            <details>
                <summary class="text-lg font-semibold py-2 flex justify-between items-center"><span>Animation System</span><span class="arrow">&#9654;</span></summary>
                <div class="space-y-4 pt-2 border-t border-gray-700">
                    <div><label for="animAxiom" class="block text-sm">Animation Axiom</label><input type="text" id="animAxiom" class="mt-1 block w-full bg-gray-700 p-2 rounded-md"></div>
                    <div><label for="animIterations" class="block text-sm">Animation Iterations: <span id="animIterations-value">6</span></label><input type="range" id="animIterations" min="0" max="10" value="6" class="w-full h-2 bg-gray-700 rounded-lg"></div>
                    <div><label for="animRules" class="block text-sm">Animation Rules</label><textarea id="animRules" rows="3" class="mt-1 block w-full bg-gray-700 p-2 rounded-md"></textarea></div>
                </div>
            </details>

            <details>
                <summary class="text-lg font-semibold py-2 flex justify-between items-center"><span>Base Geometry & Angles</span><span class="arrow">&#9654;</span></summary>
                <div class="space-y-4 pt-2 border-t border-gray-700">
                    <div class="grid grid-cols-2 gap-4">
                         <div><label for="length" class="block text-sm">Length</label><input type="number" id="length" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                        <div><label for="radius" class="block text-sm">Radius</label><input type="number" id="radius" step="0.01" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                    </div>
                    <div class="grid grid-cols-3 gap-2">
                        <div><label for="yaw" class="block text-sm">Yaw (°)</label><input type="number" id="yaw" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                        <div><label for="pitch" class="block text-sm">Pitch (°)</label><input type="number" id="pitch" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                        <div><label for="roll" class="block text-sm">Roll (°)</label><input type="number" id="roll" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                    </div>
                    <select id="segmentType" class="w-full bg-gray-700 p-2 rounded-md"><option value="cylinder">Cylinder</option><option value="box">Box</option><option value="line">Line</option><option value="text">Text</option></select>
                </div>
            </details>

            <details>
                <summary class="text-lg font-semibold py-2 flex justify-between items-center"><span>Dynamic Modifiers</span><span class="arrow">&#9654;</span></summary>
                <div class="space-y-4 pt-2 border-t border-gray-700">
                     <div class="grid grid-cols-2 gap-4">
                        <div><label for="lengthScale" class="block text-sm">Length Scale</label><input type="number" id="lengthScale" step="0.01" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                        <div><label for="radiusScale" class="block text-sm">Radius Scale</label><input type="number" id="radiusScale" step="0.01" class="mt-1 w-full bg-gray-700 p-2 rounded-md"></div>
                    </div>
                    <div class="mt-4">
                        <label for="angleScale" class="block text-sm">Angle Scale</label>
                        <input type="number" id="angleScale" step="0.01" class="mt-1 w-full bg-gray-700 p-2 rounded-md">
                    </div>
                </div>
            </details>

             <details>
                <summary class="text-lg font-semibold py-2 flex justify-between items-center"><span>Scene & Effects</span><span class="arrow">&#9654;</span></summary>
                <div class="space-y-4 pt-2 border-t border-gray-700">
                    <div class="flex items-center justify-between"><label for="bgColor" class="text-sm">Background</label><input type="color" id="bgColor" value="#111827"></div>
                    <div class="flex items-center justify-between"><label for="fogToggle" class="text-sm">Atmospheric Fog</label><div class="flex items-center gap-2"><input type="color" id="fogColor" value="#111827"><input type="checkbox" id="fogToggle" class="h-5 w-5 bg-gray-700 rounded text-indigo-500"></div></div>
                    <div class="flex items-center justify-between"><label for="bloomToggle" class="text-sm">Bloom Effect</label><input type="checkbox" id="bloomToggle" class="h-5 w-5 bg-gray-700 rounded text-indigo-500"></div>
                    <div><label for="bloomStrength" class="block text-sm">Bloom Strength: <span id="bloomStrength-value">1.5</span></label><input type="range" id="bloomStrength" min="0" max="3" step="0.1" value="1.5" class="w-full h-2 bg-gray-700 rounded-lg"></div>
                    <div><label for="bloomRadius" class="block text-sm">Bloom Radius: <span id="bloomRadius-value">0.4</span></label><input type="range" id="bloomRadius" min="0" max="1" step="0.01" value="0.4" class="w-full h-2 bg-gray-700 rounded-lg"></div>
                </div>
            </details>

             <details>
                <summary class="text-lg font-semibold py-2 flex justify-between items-center"><span>Animation Steps</span><span class="arrow">&#9654;</span></summary>
                <div class="grid grid-cols-2 gap-x-4 gap-y-2 pt-2 border-t border-gray-700">
                    <div><label for="yawStep" class="text-sm">Yaw</label><input type="number" id="yawStep" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md text-xs"></div>
                    <div><label for="pitchStep" class="text-sm">Pitch</label><input type="number" id="pitchStep" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md text-xs"></div>
                    <div><label for="rollStep" class="text-sm">Roll</label><input type="number" id="rollStep" step="0.1" class="mt-1 w-full bg-gray-700 p-2 rounded-md text-xs"></div>
                    <div><label for="lengthStep" class="text-sm">Length</label><input type="number" id="lengthStep" step="0.01" class="mt-1 w-full bg-gray-700 p-2 rounded-md text-xs"></div>
                    <div><label for="radiusStep" class="text-sm">Radius</label><input type="number" id="radiusStep" step="0.001" class="mt-1 w-full bg-gray-700 p-2 rounded-md text-xs"></div>
                    <div><label for="angleScaleStep" class="text-sm">Angle Scale</label><input type="number" id="angleScaleStep" step="0.001" class="mt-1 w-full bg-gray-700 p-2 rounded-md text-xs"></div>
                </div>
            </details>
        </div>

        <div class="mt-6 grid grid-cols-2 gap-4">
            <button id="generate-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">Generate</button>
            <button id="export-video-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">Export Video</button>
        </div>
        <div class="mt-4 flex flex-col gap-2">
            <button id="prerender-btn" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">Prerender</button>
            <div id="prerender-controls" class="mt-2 hidden">
                <span id="prerender-status" class="text-sm"></span>
            </div>
        </div>
    </div>

    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-70 items-center justify-center p-4 hidden">
        <div id="help-modal-content" class="bg-gray-800 text-white p-6 rounded-lg shadow-2xl w-full max-w-lg scale-95 opacity-0">
            <div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold">Symbol Guide</h2><button id="close-modal-btn" class="p-2 rounded-full hover:bg-gray-700 focus:outline-none">&times;</button></div>
            <div class="grid grid-cols-2 gap-6 text-gray-300 text-sm">
                <div>
                    <h3 class="font-bold text-white mb-2">Structure Symbols</h3>
                    <p><strong>F, G, H</strong>: Move & draw</p><p><strong>f, g, h</strong>: Move only</p><hr class="border-gray-600 my-2">
                    <p><strong>+ / -</strong>: Yaw right / left</p><p><strong>&amp;  | </strong>: Pitch down / up</p><p><strong>\ / /</strong>: Roll left / right</p><hr class="border-gray-600 my-2">
                    <p><strong>[ / ]</strong>: Push / Pop state</p><hr class="border-gray-600 my-2">
                    <p><strong>o</strong>: Draw a sphere</p><p><strong>! / '</strong>: Scale radius</p><p><strong>( / )</strong>: Scale length</p>
                    <p><strong>* / %</strong>: Scale angles</p><p><strong>C</strong>: Cycle color</p><p><strong>0-9</strong>: Set color</p><p><strong>$</strong>: Level horizontally</p>
                </div>
                 <div>
                    <h3 class="font-bold text-white mb-2">Animation Symbols</h3>
                    <p><strong>Y / y</strong>: Inc/dec Yaw</p>
                    <p><strong>P / p</strong>: Inc/dec Pitch</p>
                    <p><strong>R / r</strong>: Inc/dec Roll</p>
                    <hr class="border-gray-600 my-2">
                    <p><strong>L / l</strong>: Inc/dec Length</p>
                    <p><strong>W / w</strong>: Inc/dec Radius</p>
                    <hr class="border-gray-600 my-2">
                    <p><strong>S / s</strong>: Inc/dec Length Scale</p>
                    <p><strong>D / d</strong>: Inc/dec Radius Scale</p>
                    <p><strong>A / a</strong>: Inc/dec Angle Scale</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile floating action button -->
    <button id="mobile-fab" class="mobile-fab hidden" aria-label="Open menu">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
    </button>

    <script type="importmap">{"imports": {"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>

    <script type="module">
    // Prerender state
    let prerenderedImages = [];
    let prerenderedParams = [];
    let prerenderIndex = 0;

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        let scene, camera, renderer, controls, lSystemGroup, composer;
        const ui = {};
    // Palette is module-scoped so drawing code can access it
    let palette = [];
        const presets = {
            "Growing Vine": { axiom: "F", rules: "F=F[+F-F]F", animAxiom: "A", animRules: "A=YlA", animIterations: 8, iterations: 4, length: 2, radius: 0.1, yaw: 25, pitch: 20, roll: 20, lengthScale: 0.9, radiusScale: 0.9, angleScale: 1, yawStep: 1, pitchStep: 0, rollStep: 0, lengthStep: -0.005, radiusStep: 0, angleScaleStep: 0, bloomToggle: true, fogToggle: true },
            "Twisting Anemone": { axiom: "A", rules: "A=F![+B]F[-B]A\nB=C(*B)", animAxiom: "", animRules: "", animIterations: 0, iterations: 7, length: 1.2, radius: 0.08, yaw: 45, pitch: 60, roll: 20, lengthScale: 0.9, radiusScale: 0.9, angleScale: 0.95, bloomToggle: true, fogToggle: true },
            "Wandering Poet's Tree": { axiom: "F", rules: "F=C[//^^^F]C[\\\\&&&F]C[--F]C[++F]F", animAxiom: "", animRules: "", animIterations: 0, iterations: 5, length: 0.8, radius: 0.04, yaw: 22, pitch: 22, roll: 22, lengthScale: 0.9, radiusScale: 0.8, angleScale: 1, bloomToggle: true, fogToggle: true },
            "Fractal Plant": { axiom: "X", rules: "X=F-[[X]+X]+F[+FX]-X\nF=FF", animAxiom: "", animRules: "", animIterations: 0, iterations: 5, length: 1.5, radius: 0.1, yaw: 22.5, pitch: 22.5, roll: 22.5, lengthScale: 0.9, radiusScale: 0.9, angleScale: 1, bloomToggle: false, fogToggle: false },
            "Rainbow Bush": { axiom: "A", rules: "A=C![+A][-A]F%A\nF=FF", animAxiom: "", animRules: "", animIterations: 0, iterations: 6, length: 1, radius: 0.1, yaw: 35, pitch: 35, roll: 35, lengthScale: 0.9, radiusScale: 0.7, angleScale: 1.1, bloomToggle: true, fogToggle: false },
        };

        function loadPreset(name) {
            const p = presets[name];
            for (const key in p) {
                const el = ui[key];
                if (el) {
                    if (el.type === 'checkbox') {
                        el.checked = p[key];
                    } else {
                        el.value = p[key];
                    }
                    const valueEl = ui[`${key}Value`];
                    if (valueEl) {
                        valueEl.textContent = p[key];
                    }
                }
            }
            updateEffects();
            handleGenerateClick();
        }
        
        function setupPostProcessing() {
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            const outputPass = new OutputPass();
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);
            ui.bloomPass = bloomPass;
            updateEffects();
        }

        function updateEffects() {
            if (!ui.bgColor || !ui.fogToggle || !ui.bloomPass) return;
            scene.background = new THREE.Color(ui.bgColor.value);
            scene.fog = ui.fogToggle.checked ? new THREE.Fog(ui.fogColor.value, 50, 250) : null;
            ui.bloomPass.enabled = ui.bloomToggle.checked;
            ui.bloomPass.strength = parseFloat(ui.bloomStrength.value);
            ui.bloomPass.radius = parseFloat(ui.bloomRadius.value);
        }

        function init() {
            // Prerender UI
            ui.prerenderBtn = document.getElementById('prerender-btn');
            ui.prerenderControls = document.getElementById('prerender-controls');
            ui.prerenderStatus = document.getElementById('prerender-status');
            ui.prerenderBtn.addEventListener('click', handlePrerenderClick);
            // Palette UI setup
            const defaultPalette = ["#00FF00", "#ef4444", "#3b82f6", "#f97316", "#8b5cf6", "#14b8a6", "#ec4899", "#facc15", "#65a30d", "#22d3ee"];
            if (!palette || palette.length === 0) palette = [...defaultPalette];
            const palettePickers = document.getElementById('palette-pickers');
            function renderPalettePickers() {
                palettePickers.innerHTML = '';
                palette.forEach((color, idx) => {
                    const input = document.createElement('input');
                    input.type = 'color';
                    input.value = color;
                    input.className = 'rounded shadow border-2 border-gray-600';
                    input.title = `Palette color ${idx+1}`;
                    input.addEventListener('input', e => {
                        palette[idx] = e.target.value;
                        updateLSystem(false);
                    });
                    palettePickers.appendChild(input);
                });
            }
            renderPalettePickers();

            // Expose palette for programmatic use
            window.setPalette = function(newPalette) {
                if (Array.isArray(newPalette) && newPalette.length > 0) {
                    palette = newPalette.map(c => c.startsWith('#') ? c : `#${c}`);
                    renderPalettePickers();
                    updateLSystem(false);
                }
            };
            const uiMap = {
                axiom: 'axiom', rules: 'rules', iterations: 'iterations', iterationsValue: 'iterations-value',
                animAxiom: 'animAxiom', animRules: 'animRules', animIterations: 'animIterations', animIterationsValue: 'animIterations-value',
                length: 'length', radius: 'radius', yaw: 'yaw', pitch: 'pitch', roll: 'roll',
                lengthScale: 'lengthScale', radiusScale: 'radiusScale', angleScale: 'angleScale', segmentType: 'segmentType',
                yawStep: 'yawStep', pitchStep: 'pitchStep', rollStep: 'rollStep', lengthStep: 'lengthStep', radiusStep: 'radiusStep', angleScaleStep: 'angleScaleStep',
                presets: 'presets', generateBtn: 'generate-btn', exportVideoBtn: 'export-video-btn',
                uiPanel: 'ui-panel', toggleButton: 'toggle-button', helpBtn: 'help-btn',
                helpModal: 'help-modal', helpModalContent: 'help-modal-content', closeModalBtn: 'close-modal-btn',
                progressOverlay: 'progress-overlay', progressText: 'progress-text', bgColor: 'bgColor',
                fogColor: 'fogColor', fogToggle: 'fogToggle', bloomToggle: 'bloomToggle',
                bloomStrength: 'bloomStrength', bloomStrengthValue: 'bloomStrength-value',
                bloomRadius: 'bloomRadius', bloomRadiusValue: 'bloomRadius-value'
            };
            for (const key in uiMap) { ui[key] = document.getElementById(uiMap[key]); }

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 20, 50);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            // Mobile FAB visibility
            const mobileFab = document.getElementById('mobile-fab');
            function updateFabVisibility() {
                if (window.matchMedia && window.matchMedia('(max-width: 640px)').matches) {
                    mobileFab.classList.remove('hidden');
                } else {
                    mobileFab.classList.add('hidden');
                }
            }
            updateFabVisibility();
            window.addEventListener('resize', updateFabVisibility);

            // Long-press logic to open centered UI (no controls near touch)
            let pressTimer = null;
            const longPressDuration = 550; // ms
            const canvas = renderer.domElement;
            function openMobileUI() {
                ui.uiPanel.classList.add('mobile-modal');
                ui.uiPanel.classList.remove('hidden');
            }
            function closeMobileUI() {
                ui.uiPanel.classList.remove('mobile-modal');
                ui.uiPanel.classList.add('hidden');
            }
            mobileFab.addEventListener('click', () => {
                if (ui.uiPanel.classList.contains('hidden')) openMobileUI(); else closeMobileUI();
            });

            function startPress() { if (pressTimer == null) pressTimer = setTimeout(() => { openMobileUI(); pressTimer = null; }, longPressDuration); }
            function cancelPress() { if (pressTimer != null) { clearTimeout(pressTimer); pressTimer = null; } }
            // touch events
            canvas.addEventListener('touchstart', startPress, { passive: true });
            canvas.addEventListener('touchend', cancelPress);
            canvas.addEventListener('touchmove', cancelPress);
            // mouse events for desktop long-press
            canvas.addEventListener('mousedown', startPress);
            window.addEventListener('mouseup', cancelPress);
            
            scene.add(new THREE.AmbientLight(0xcccccc, 0.1));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 8);
            directionalLight.intensity = 2.5;
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0);
            controls.update();
            lSystemGroup = new THREE.Group();
            scene.add(lSystemGroup);

            setupPostProcessing();

            Object.keys(presets).forEach(name => ui.presets.appendChild(new Option(name, name)));
            
            ui.presets.addEventListener('change', (e) => loadPreset(e.target.value));
            ui.generateBtn.addEventListener('click', handleGenerateClick);
            ui.exportVideoBtn.addEventListener('click', exportVideo);
            ui.toggleButton.addEventListener('click', toggleUIPanel);
            ui.helpBtn.addEventListener('click', showHelpModal);
            ui.closeModalBtn.addEventListener('click', hideHelpModal);
            ui.helpModal.addEventListener('click', (e) => e.target === ui.helpModal && hideHelpModal());
            
            ['bgColor', 'fogColor', 'fogToggle', 'bloomToggle', 'bloomStrength', 'bloomRadius'].forEach(id => ui[id].addEventListener('input', updateEffects));
            ui.iterations.addEventListener('input', () => ui.iterationsValue.textContent = ui.iterations.value);
            ui.animIterations.addEventListener('input', () => ui.animIterationsValue.textContent = ui.animIterations.value);
            ui.bloomStrength.addEventListener('input', () => ui.bloomStrengthValue.textContent = ui.bloomStrength.value);
            ui.bloomRadius.addEventListener('input', () => ui.bloomRadiusValue.textContent = ui.bloomRadius.value);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'h') toggleUIPanel();
                if (e.key.toLowerCase() === 'm') showHelpModal();
                if (e.key.toLowerCase() === 'g') handleGenerateClick();
                if (e.key.toLowerCase() === 'r') resetScene();
                if (e.key.toLowerCase() === 'p') togglePostProcessing();
            });
            
            loadPreset("Growing Vine");
            animate();
        }

        function generateLSystem(axiom, rules, iterations) {
            // --- Simple character-based L-System (no parameters) ---
            // Parse rules into a map: single-charcter head -> replacement string
            const ruleLines = (rules || '').split('\n').map(l => l.trim()).filter(Boolean);
            const ruleMap = new Map();
            for (const line of ruleLines) {
                const parts = line.split('=');
                if (parts.length < 2) continue;
                const head = parts[0].trim();
                const body = parts.slice(1).join('=').trim();
                if (head.length === 0) continue;
                // use only first character of head for simple L-systems
                ruleMap.set(head[0], body);
            }

            let current = (axiom || '').toString();
            for (let iter = 0; iter < iterations; iter++) {
                let next = '';
                for (let i = 0; i < current.length; i++) {
                    const ch = current[i];
                    if (ruleMap.has(ch)) next += ruleMap.get(ch);
                    else next += ch;
                }
                current = next;
            }

            // Convert final string into modules (sym, params=[])
            const modules = current.split('').map(ch => ({ sym: ch, params: [] }));
            console.log('L-System final string:', current);
            return modules;
        }

        function drawLSystem(lindenmayerModules) {
            while (lSystemGroup.children.length > 0) {
                const child = lSystemGroup.children[0];
                lSystemGroup.remove(child);
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
            }
            lSystemGroup.position.set(0, 0, 0);

            // Use palette from UI
            // Use palette from UI, but only create one material and change its color
            const paletteColors = palette.map(c => new THREE.Color(c));
            const baseMaterial = new THREE.MeshPhongMaterial({ color: paletteColors[0], side: THREE.DoubleSide });
            const materials = { fruit: new THREE.MeshPhongMaterial({ color: 0xea580c }) };

            const turtle = {
                position: new THREE.Vector3(0, 0, 0), quaternion: new THREE.Quaternion(),
                length: parseFloat(ui.length.value), radius: parseFloat(ui.radius.value),
                yaw: THREE.MathUtils.degToRad(parseFloat(ui.yaw.value)),
                pitch: THREE.MathUtils.degToRad(parseFloat(ui.pitch.value)),
                roll: THREE.MathUtils.degToRad(parseFloat(ui.roll.value)),
                colorIndex: 0, material: baseMaterial
            };
            const stateStack = [];
            const stateQueue = [];
            const lengthScale = parseFloat(ui.lengthScale.value);
            const radiusScale = parseFloat(ui.radiusScale.value);
            const angleScale = parseFloat(ui.angleScale.value);

            for (const module of lindenmayerModules) {
                switch (module.sym) {
                    case 'F': case 'G': case 'H': {
                        const len = module.params.length > 0 ? module.params[0] : turtle.length;
                        const rad = module.params.length > 1 ? module.params[1] : turtle.radius;
                        const dir = new THREE.Vector3(0, 1, 0).applyQuaternion(turtle.quaternion);
                        const start = turtle.position.clone();
                        turtle.position.add(dir.clone().multiplyScalar(len));
                        if (ui.segmentType.value !== 'line' && rad > 0.001 && len > 0.001 && isFinite(rad) && isFinite(len)) {
                            let geom;
                            if (ui.segmentType.value === 'text') geom = new THREE.TextGeometry( 'Greg', {
                                                                            font: font,
                                                                            size: int(len) *3,
                                                                            depth: rad * 2,
                                                                            curveSegments: 12,
                                                                            bevelEnabled: true,
                                                                            bevelThickness: 10,
                                                                            bevelSize: 8,
                                                                            bevelOffset: 0,
                                                                            bevelSegments: 5} );
                            else if (ui.segmentType.value === 'cylinder') geom = new THREE.CylinderGeometry(rad, rad, len, 8);
                            else geom = new THREE.BoxGeometry(rad * 2, len, rad * 2);
                            // Clone the material so each segment can have its own color
                            const segMaterial = turtle.material.clone();
                            segMaterial.color.copy(turtle.material.color);
                            const seg = new THREE.Mesh(geom, segMaterial);
                            seg.position.copy(start).add(turtle.position).multiplyScalar(0.5);
                            seg.quaternion.copy(turtle.quaternion);
                            lSystemGroup.add(seg);
                        }
                        break;
                    }
                    case 'f': case 'g': case 'h': {
                        const len = turtle.length;
                        const dir = new THREE.Vector3(0, 1, 0).applyQuaternion(turtle.quaternion);
                        turtle.position.add(dir.clone().multiplyScalar(len));
                        break;
                    }
                    case '+': turtle.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -turtle.yaw)); break;
                    case '-': turtle.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), turtle.yaw)); break;
                    case '&': turtle.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), turtle.pitch)); break;
                    case '|': turtle.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -turtle.pitch)); break;
                    case '\\': turtle.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), turtle.roll)); break;
                    case '/': turtle.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -turtle.roll)); break;
                    case '[': stateStack.push({ ...turtle, position: turtle.position.clone(), quaternion: turtle.quaternion.clone() }); break;
                    case ']': Object.assign(turtle, stateStack.pop()); break;
                    case '{': stateQueue.push({ ...turtle, position: turtle.position.clone(), quaternion: turtle.quaternion.clone() }); break;
                    case '}': if (stateQueue.length > 0) { Object.assign(turtle, stateQueue.shift()); } break;
                    case 'o': {
                        if (turtle.radius > 0.001) {
                            const fruit = new THREE.Mesh(new THREE.SphereGeometry(turtle.radius * 2.5, 16, 12), materials.fruit);
                            fruit.position.copy(turtle.position);
                            lSystemGroup.add(fruit);
                        }
                        break;
                    }
                    case '<': turtle.position.y -= turtle.length; break;
                    case '>': turtle.position.y += turtle.length; break;
                    case '^': turtle.position.z += turtle.length; break;
                    case 'v': turtle.position.z -= turtle.length; break;
                    case '!': turtle.radius *= radiusScale; break;
                    case "'": turtle.radius /= radiusScale; break;
                    case '(': turtle.length *= lengthScale; break;
                    case ')': turtle.length /= lengthScale; break;
                    case '*': turtle.yaw *= angleScale; break;
                    case '%': turtle.yaw /= angleScale; break;
                    case '#': turtle.pitch *= angleScale; break;
                    case '$': turtle.pitch /= angleScale; break;
                    case '@': turtle.roll *= angleScale; break;
                    case '~': turtle.roll /= angleScale; break;
                    case 'C':
                    case 'C ': {
                        turtle.colorIndex = (turtle.colorIndex + 1) % paletteColors.length;
                        turtle.material.color.copy(paletteColors[turtle.colorIndex]);
                        break;
                    }
                    case 'D':
                    case 'D ': {
                        turtle.colorIndex = (turtle.colorIndex - 1 + paletteColors.length) % paletteColors.length;
                        turtle.material.color.copy(paletteColors[turtle.colorIndex]);
                        break;
                    }
                    default:
                        if (!isNaN(parseInt(module.sym))) {
                            turtle.colorIndex = parseInt(module.sym) % paletteColors.length;
                            turtle.material.color.copy(paletteColors[turtle.colorIndex]);
                        }
                        break;
                }
            }
            // Dispose only the fruit material (palette materials are not created in bulk anymore)
            Object.values(materials).forEach(mat => mat.dispose());
        }
        
        function autoFrameCamera() {
            if (lSystemGroup.children.length === 0) return;
            const box = new THREE.Box3().setFromObject(lSystemGroup);
            const center = box.getCenter(new THREE.Vector3());
            const sphere = box.getBoundingSphere(new THREE.Sphere());

            lSystemGroup.position.sub(center);
            controls.target.set(0, 0, 0);

            const fov = camera.fov * (Math.PI / 180);
            const distance = sphere.radius / Math.sin(fov / 2);
            const cameraZ = distance * 1.1;

            if (isNaN(cameraZ) || !isFinite(cameraZ) || cameraZ < 0.1) return;

            camera.position.set(0, 0, cameraZ);
            camera.near = cameraZ / 100;
            camera.far = cameraZ * 100;
            camera.updateProjectionMatrix();
            controls.update();
        }

        function updateLSystem(shouldAutoFrame = false) {
            try {
                const lindenmayerModules = generateLSystem(ui.axiom.value, ui.rules.value, parseInt(ui.iterations.value, 10));
                drawLSystem(lindenmayerModules);
            } catch (error) {
                console.error("An error occurred during generation:", error);
            }
            if (shouldAutoFrame) autoFrameCamera();
        }

        function handleGenerateClick() {
            ui.generateBtn.textContent = 'Generating...';
            ui.generateBtn.disabled = true;
            setTimeout(() => {
                updateLSystem(true);
                ui.generateBtn.textContent = 'Generate';
                ui.generateBtn.disabled = false;
            }, 10);
        }
        
        async function exportVideo() {
            hideUIPanel();
            await new Promise(resolve => setTimeout(resolve, 350));

            const capturer = new CCapture({ format: 'webm', framerate: 16, verbose: false });
            
            ui.exportVideoBtn.disabled = true;
            ui.generateBtn.disabled = true;
            ui.progressOverlay.classList.remove('hidden');
            ui.progressOverlay.classList.add('flex');

            try {
                capturer.start();
                const animationString = generateLSystem(ui.animAxiom.value, ui.animRules.value, parseInt(ui.animIterations.value, 10));
                const steps = {
                    Y: parseFloat(ui.yawStep.value), y: -parseFloat(ui.yawStep.value),
                    P: parseFloat(ui.pitchStep.value), p: -parseFloat(ui.pitchStep.value),
                    R: parseFloat(ui.rollStep.value), r: -parseFloat(ui.rollStep.value),
                    L: parseFloat(ui.lengthStep.value), l: -parseFloat(ui.lengthStep.value),
                    W: parseFloat(ui.radiusStep.value), w: -parseFloat(ui.radiusStep.value),
                    A: parseFloat(ui.angleScaleStep.value), a: -parseFloat(ui.angleScaleStep.value),
                };

                for (let i = 0; i < animationString.length; i++) {
                    const command = animationString[i];
                    ui.progressText.textContent = `Recording Frame ${i + 1}/${animationString.length}`;

                    switch(command) {
                        case 'Y': case 'y': ui.yaw.value = (parseFloat(ui.yaw.value) + steps[command]).toFixed(2); break;
                        case 'P': case 'p': ui.pitch.value = (parseFloat(ui.pitch.value) + steps[command]).toFixed(2); break;
                        case 'R': case 'r': ui.roll.value = (parseFloat(ui.roll.value) + steps[command]).toFixed(2); break;
                        case 'L': case 'l': ui.length.value = (parseFloat(ui.length.value) + steps[command]).toFixed(3); break;
                        case 'W': case 'w': ui.radius.value = (parseFloat(ui.radius.value) + steps[command]).toFixed(4); break;
                        case 'A': case 'a': ui.angleScale.value = (parseFloat(ui.angleScale.value) + steps[command]).toFixed(3); break;
                    }

                    updateLSystem(false);
                    capturer.capture(renderer.domElement);
                    await new Promise(resolve => requestAnimationFrame(resolve));
                }

                ui.progressText.textContent = 'Saving...';
                capturer.stop();
                capturer.save();
            } catch (e) {
                console.error("Video export failed:", e);
            } finally {
                ui.progressOverlay.classList.add('hidden');
                ui.progressOverlay.classList.remove('flex');
                ui.exportVideoBtn.disabled = false;
                ui.generateBtn.disabled = false;
                showUIPanel();
            }
        }

        function hideUIPanel() { if (!ui.uiPanel.classList.contains('hidden')) toggleUIPanel(); }
        function showUIPanel() { if (ui.uiPanel.classList.contains('hidden')) toggleUIPanel(); }
        function toggleUIPanel() {
            ui.uiPanel.classList.toggle('hidden');
            ui.toggleButton.classList.toggle('collapsed');
        }

        function showHelpModal() {
            ui.helpModal.classList.remove('hidden');
            ui.helpModal.classList.add('flex');
            setTimeout(() => {
                ui.helpModal.classList.remove('opacity-0');
                ui.helpModalContent.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function hideHelpModal() {
            ui.helpModal.classList.add('opacity-0');
            ui.helpModalContent.classList.add('scale-95', 'opacity-0');
            setTimeout(() => ui.helpModal.classList.add('hidden'), 200);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {

            // If in prerender view mode, do not animate scene
            if (ui.prerenderControls && !ui.prerenderControls.classList.contains('hidden')) return;

            controls.update();
            composer.render();
            requestAnimationFrame(animate);
        }

        window.addEventListener('DOMContentLoaded', init);

        // Prerender logic
        async function handlePrerenderClick() {
            // Prompt for A and B (comma-separated values)
            let aStr = prompt('Enter values for A (comma-separated):', '1,2,3');
            let bStr = prompt('Enter values for B (comma-separated):', '10,20,30');
            if (!aStr || !bStr) return;
            let A = aStr.split(',').map(s => s.trim()).filter(Boolean);
            let B = bStr.split(',').map(s => s.trim()).filter(Boolean);
            if (A.length === 0 || B.length === 0) return;

            prerenderedImages = [];
            prerenderedParams = [];
            prerenderIndex = 0;
            ui.prerenderControls.classList.remove('hidden');
            ui.prerenderStatus.textContent = 'Prerendering...';

            // Choose which UI fields to assign (for demo: assign A to length, B to yaw)
            // You can customize this mapping as needed
            const paramA = 'length';
            const paramB = 'yaw';

            // For each (a, b) pair, set params, render, and store image
            for (let i = 0; i < A.length; ++i) {
                for (let j = 0; j < B.length; ++j) {
                    ui[paramA].value = A[i];
                    ui[paramB].value = B[j];
                    updateLSystem(false);
                    await new Promise(r => setTimeout(r, 30)); // let render update
                    // Capture image from renderer
                    const dataUrl = renderer.domElement.toDataURL('image/png');
                    prerenderedImages.push(dataUrl);
                    prerenderedParams.push({ [paramA]: A[i], [paramB]: B[j] });
                }
            }
            prerenderIndex = 0;
            showPrerendered(0);
        }

        function showPrerendered(idx) {
            if (prerenderedImages.length === 0) return;
            prerenderIndex = (idx + prerenderedImages.length) % prerenderedImages.length;
            // Show image overlay
            let overlay = document.getElementById('prerender-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'prerender-overlay';
                overlay.style.position = 'fixed';
                overlay.style.left = '0';
                overlay.style.top = '0';
                overlay.style.width = '100vw';
                overlay.style.height = '100vh';
                overlay.style.background = 'rgba(0,0,0,0.92)';
                overlay.style.display = 'flex';
                overlay.style.flexDirection = 'column';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.zIndex = '10010';
                // Only close overlay if click background, not controls
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                        ui.prerenderControls.classList.add('hidden');
                    }
                });
                document.body.appendChild(overlay);
            }
            overlay.innerHTML = '';
            const img = document.createElement('img');
            img.src = prerenderedImages[prerenderIndex];
            img.style.maxWidth = '90vw';
            img.style.maxHeight = '70vh';
            img.style.border = '6px solid #fff';
            img.style.borderRadius = '18px';
            img.style.boxShadow = '0 8px 32px #000a';
            overlay.appendChild(img);
            // Show params
            const params = prerenderedParams[prerenderIndex];
            const label = document.createElement('div');
            label.textContent = `A: ${params.length}, B: ${params.yaw}`;
            label.style.marginTop = '18px';
            label.style.background = 'rgba(30,30,40,0.9)';
            label.style.color = '#fff';
            label.style.padding = '8px 18px';
            label.style.borderRadius = '8px';
            label.style.fontSize = '1.2em';
            overlay.appendChild(label);
            // Prev/Next controls
            const nav = document.createElement('div');
            nav.style.display = 'flex';
            nav.style.gap = '18px';
            nav.style.marginTop = '18px';
            nav.style.alignItems = 'center';
            const prevBtn = document.createElement('button');
            prevBtn.textContent = 'Prev';
            prevBtn.className = 'bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded text-lg';
            prevBtn.onclick = (e) => { e.stopPropagation(); showPrerendered(prerenderIndex - 1); };
            const status = document.createElement('span');
            status.textContent = `Shape ${prerenderIndex + 1} / ${prerenderedImages.length}`;
            status.style.color = '#fff';
            status.style.fontSize = '1.1em';
            const nextBtn = document.createElement('button');
            nextBtn.textContent = 'Next';
            nextBtn.className = 'bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded text-lg';
            nextBtn.onclick = (e) => { e.stopPropagation(); showPrerendered(prerenderIndex + 1); };
            nav.appendChild(prevBtn);
            nav.appendChild(status);
            nav.appendChild(nextBtn);
            overlay.appendChild(nav);
            // Update status in hidden controls for accessibility
            ui.prerenderStatus.textContent = `Shape ${prerenderIndex + 1} / ${prerenderedImages.length}`;
        }
    </script>
</body>
</html>
